<root data-root="JavaScript BOM">
    <!-- 概述 -->
    <section class="mt0">
    	<h3>JavaScript BOM概述</h3>
    	<p><em>BOM</em>（Browers Object Model，浏览器对象模型）是浏览器为JavaScript提供的一个<em>API</em>（Application Programming Interface，应用编程接口），所以它不是原生JavaScript提供的。通过BOM我们可以访问和设置浏览器的一些属性和函数。</p>
    	<p>对于BOM的几乎所有操作都以依赖一个<em>全局对象</em>，那就是“<em>window</em>”对象。由于它是一个全局对象，所以很多时候在访问它内部的子对象的属性和方法的时候都是可以将window一词省略不写的，如“window.screen”可以直接写成“screen”也正常访问该子对象。</p>
    	<p>window对象下主要包含了以下子对象：</p>
    	<ul class="indent">
    		<li>document：文档对象</li>
    		<li>frames：浏览器的框架（如iframe和现在废弃了的frameset）</li>
    		<li>history：浏览器浏览历史对象</li>
    		<li>location：浏览器页面所处位置对象</li>
    		<li>navigator：浏览器信息导航对象</li>
    		<li>screen：浏览器屏幕对象</li>
    	</ul>
    	<p>除了这些属性，window对象还提供了一些方法函数，如：alert()、open()、close()、setTimeout()、clearTimeout()、setIntelval()、clearInterval()等。</p>
    	<p>BOM到现在都没有一个组织对其进行标准化，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C，但这并不妨碍浏览器厂商们对其的支持。随着Web编程技术的发展，浏览器厂商在很多BOM的内容上都达成了共识，这使得很多没有标准的属性和方法也可以在大多数现代浏览器上正常的使用。</p>
    	<p>在全局环境下，window对象以下几种表示法：</p>
    	<ul class="indent">
    		<li>window</li>
    		<li>this</li>
    		<li>self</li>
    		<li>fremes</li>
    	</ul>
    	<p>它们在全局环境下都是指向window对象：</p>
    	<code class="indent">
			<img src="img/code/jscode/code-js-335.jpg">
		</code>
    	<p>window对象下的属性和方法非常之多，多至现在也没有一份权威的统计表明window下到底有多少个属性和方法，这个只需要打开Google Chrome（主要推荐，但也可以是其它非IE系列的主流浏览器）的控制台（ctrl+shift+J），然后输入“window.”（后面需要加上“点”）就可以看到window下的属性们了，而且里面很多属性下还包含二级、三级甚至更多级的属性。也就是说想要完全去掌握window下的所有属性和方法肯定是不现实的，我们只需要掌握一些常用的，对我们实际项目开发中有一定帮助的即可。接下来我们我们开始对window的这些主要属性和方法进行讲解。</p>
	</section>
	<!-- 打开和关闭窗口 -->
	<section>
		<h3>window.open()和window.close()</h3>
		<p>window.open()方法用于打开一个新的窗口（或标签页），而window.close()用于关闭当前窗口，他们同样可以将方法前的window对象省略不写，也能达到同样的方法效果。</p>
		<p>相比于close()方法用于直接关闭浏览器窗口，open()方法就要稍微复杂一些，该方法有4个可选参数，它们的作用分别是：</p>
		<dl class="attrExplain">
			<dt>URL</dt>
			<dd>新窗口的URL，为一个字符串。</dd>

			<dt>名称</dt>
			<dd>新窗口的名称，为一个字符串。</dd>

			<dt>窗口特性</dt>
			<dd>新窗口的URL，为一个字符串。具体可以配置以下内容：</dd>
			<dd>
				<ul>
					<li>width：窗口宽度，值为一个像素数值</li>
					<li>height：窗口高度，值为一个像素数值</li>
					<li>left：窗口的屏幕X坐标，值为一个像素数值</li>
					<li>top：窗口的屏幕Y坐标，值为一个像素数值</li>
					<li>channelmode：是否“影院模式”显示窗口，值：yes/no（默认）</li>
					<li>fullscreen：是否全屏显示，处于全屏模式的窗口必须同时处于剧院模式，值：yes/no（默认）</li>
					<li>directories：是否添加目录按钮，值：yes（默认）/no</li>
					<li>location：是否显示地址字段，值：yes（默认）/no</li>
					<li>menubar：是否显示菜单栏，值：yes（默认）/no</li>
					<li>resizable：窗口是否可以调整尺寸，值：yes（默认）/no</li>
					<li>scrollbars：是否显示滚动条，值：yes（默认）/no</li>
					<li>status：是否显示状态栏，值：yes（默认）/no</li>
					<li>titlebar：是否显示标题栏，值：yes（默认）/no</li>
					<li>toolbar：是否显示工具栏，值：yes（默认）/no</li>
				</ul>
			</dd>
			<dd>在这些配置项中，各浏览器的支持情况都不是很理想，在目前标准（包括HTML5标准和ECMAScript标准）支持最好的Google Chrome上也只支持上面的前四个配置。所以，如非定制浏览器开发，否则没有必要去进行配置。</dd>

			<dt>记录</dt>
			<dd>在浏览器历史中替换或新建记录，为一个布尔值。true为替换，false为新建。</dd>
		</dl>
		<p class="noindent">通过这样一个示例来简单了解该方法的配置方式，HTML代码如下：</p>
		<code>
			<img src="img/code/jscode/code-js-331.jpg">
		</code>
		<p class="noindent">JavaScript代码：</p>
		<code>
			<img src="img/code/jscode/code-js-332.jpg">
		</code>
		<h4><a href="html-pages/javascript/codeEffect/code-004.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun class="codeEffect" src="html-pages/javascript/codeEffect/code-004.html"></iframe>
	</section>

	<!-- document -->
	<section>
		<h3>document对象</h3>
		<p>对于window对象来说，document和DOM里面的document还是稍稍有些区别的，window对象的document子对象只有一个属性，就是“all”属性，它可以返回当前页面的标签集合，组成一个类似数组。</p>
		<p>我们现在先新建一个只有基本文档结构的HTML页面：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-333.jpg">
		</code>
		<p>然后在这个页面的控制台里测试这个属性：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-334.jpg">
		</code>
		<p>该属性已经被，标准化的DOM操作所代替，不过在一些较老的项目里仍然可以看到其身影。</p>
	</section>

	<!-- frames -->
	<section>
		<h3>frames对象</h3>
		<p>在这一章的第一节中通过例子我们已经见到过，frames和window是严格相等的，实际上，frames只是window的别名，它们表示的应用场景是不一样的。但只要window具有的属性，frames也具有，反之也成立。</p>
		<p>为了证明上述，我们先在一个新建的HTML文件中写如三个带有name属性的&lt;iframe&gt;标签：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-336.jpg">
		</code>
		<p>然后我们就当前的页面在控制台中做一些测试：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-337.jpg">
		</code>
		<p>通过这个测试可以发现，window对象和frames对象完全是同一个对象，它们都是内存里那个window对象的引用，其中一个对象的属性发生变化，和它相关的对象随之变化。</p>
		<p>其实在之前我们的HTML课程中就提到过，&lt;iframe&gt;标签就是“浏览器窗口中嵌入的浏览器窗口”。像上面那3个已经具有了name属性的&lt;iframe&gt;标签我们可以通过这样的形式去访问：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-338.jpg">
		</code>
		<p>通过这个测试又可以发现，不仅可以简单地通过frames对象简单地去访问这些iframe;，而且它们返回的结果和之前我们看到的window等同引用的对象的返回结果基本是一样的，注意这里说的是“基本一样”，因为从最后三个测试结果可以发现，这三个iframe是互不相等的。</p>
		<p>要访问页面内指定的iframe除了上面提供的方法外，还可以用索引下标或中括号字符串的形式去访问。比如说现在我们要访问刚才那个name属性为“iframe2”的&lt;iframe&gt;标签，还可以使用下面两种形式：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-339.jpg">
		</code>
		<p>在Ajax不盛行的年代，&lt;iframe&gt;标签是在页面内嵌入网站的最好选择，单随着JavaScript相关编程技术的高速发展，使用&lt;iframe&gt;标签嵌套子页面的形式已经开始不被推荐，而是用Ajax的异步加载的形式去请求“<em title="不是整个HMLT页面，而是只包含基本HTML标签的HTML页面，而且不包含&lt;body&gt;标签">文档片段</em>”，这样可以使得页面不需要再去加载子页面内的整个个css和js等文件，和一些不必要的标签（包括整个&lt;head&gt;标签和文档声明）。这样一来就使得页面加载的速度得到很大提升，页面也不会因为跳转刷新出现短暂白屏的情况，从而使得用户体验得到提升。不需要页面跳转，网站所有功能都通过一个页面完成的页面现在的术语叫法为“<em>SPA</em>”（single page application，译为：单页面应用程序。也有叫“SPWA”，其中的“W”表示“web”），是现在Web互联网应用开发的一个主流趋势。</p>
	</section>

	<!-- 屏幕 -->
	<section>
		<h3>屏幕相关对象</h3>
		<p>屏幕对象和相关的属性都是只读的，它们返回浏览器相对于当前计算机屏幕的数据信息。</p>
		<p>screen对象是用于描述当前浏览器相对于屏幕信息的主要对象，所含属性如下：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-340.jpg">
		</code>
		<p>其中availWidth和availHeight表示的是当前的浏览器窗口相对于屏幕而言的可用宽度和高度，而colorDepth和pixelDepth表示的是颜色深度和像素深度这些色彩图形学上的东西。</p>
		<p>和屏幕相关的还有以下属性：</p>
		<ul class="indent">
			<li>screenLeft：返回当前浏览器窗口距离屏幕左侧的像素数值</li>
			<li>screenTop：返回当前浏览器窗口距离屏幕上侧的像素数值</li>
			<li>screenX：作用和screenLeft相同</li>
			<li>screenY：作用和screenTop相同</li>
		</ul>
		<p>之所以出现这样同功能的属性归根到底，还是因为BOM一直没有一个标准造成的，根据资料显示支持screenLeft和screenTop的浏览器有：IE、Chrome、Safari、Opera，但Firxfox不支持。而支持screenX和screenY的浏览器有：Firxfox、Chrome、Safari、Opera，但IE不支持。</p>
		<p>为了解决这样兼容性问题，我们可以用一个自定义的三元表达式的办法来解决：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-341.jpg">
		</code>
		<p>现在我们就尝试多次调整浏览器窗口来试验一下刚才自定义的“属性”：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-342.jpg">
		</code>
		<p>但是需要注意的是使用我们自定义变量来接收浏览器屏幕信息需要每次窗口移动后都要进行一次表达值赋值，否则我们的“属性值”永远是第一次取到的值。显然这样的做法并不好，但由于BOM标准的问题，这也是一种不得已而为之的办法，只是一种浏览器兼容性的方案。</p>
	</section>

	<!-- 窗口 -->
	<section>
		<h3>浏览器窗口属性</h3>
		<p>用于描述当前浏览器窗口的相关属性，这对于现在这个屏幕小到“160x160”（如智能手表），大到“4096×2160”（4K屏幕）的互联网时代来说，要做到同一个项目在不同分辨率屏幕的设备上做出响应式的设计一直是前端开发工程师头痛的问题。虽然说现在已经有很多CSS框架都或多或少的能帮上一些忙，但它们都有各自的局限性，而且还存在一些学习成本。但是如果能掌握原生JavaScript一些关于浏览器窗口的属性，对于我们做响应式设计也有不小的帮助。</p>
		<p>浏览器窗口相关的主要属性有以下（数值表示的统一为像素）：</p>
		<ul class="indent">
			<li>window.innerWidth：浏览器窗口的可见宽度</li>
			<li>window.innerHeight：浏览器窗口的可见高度</li>
			<li>window.outerWidth：浏览器窗口的实际宽度（包括浏览器菜单和边框）</li>
			<li>window.outerHeight：浏览器窗口的实际高度（包括浏览器菜单和边框）</li>
			<li>window.pageXOffset：浏览器窗口滚动条水平滚动的距离</li>
			<li>window.pageYOffset：浏览器窗口滚动条垂直滚动的距离</li>
		</ul>
		<p>现在我们在HTML里放入一些标签内容（内容略），并缩放浏览器窗口到一个任意的大小和将出现的水平和垂直滚动条都进行一定程度的拖动，然后在控制台输出这些属性（省略了window对象）：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-343.jpg">
		</code>
		<p>需要注意的是innerWidth、innerHeight、outerWidth、outerHeight都会包含滚动条的宽度。</p>
		<p>这些属性都是只读的，它们会根据当前浏览器的尺寸或内容的变化而动态地跟随变化。</p>
	</section>
	<!-- navigator -->
	<section>
		<h3>navigator对象</h3>
		<p>这个对象用来包含浏览器详细信息的对象，通常用于做浏览器兼容性处理和设备的响应设计。可以打开浏览器输入这个navigator对象的名称来查看不同的浏览器的相关属性，这里我们还是以现在国内使用量<a href="http://tongji.baidu.com/data/browser" target="_blank">排行第一</a>（并且也是最长时间来对<a href="http://html5test.com/" target="_blank">HTML5</a>和<a href="https://kangax.github.io/compat-table/es6/" target="_blank">ECMAScript 6</a>支持最好的浏览器）的Google Chrome进行测试：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-344.jpg">
		</code>
		<p>在控制台输出的内容为一个对象，对象展开后会包含比较多的属性（由于测试环境分辨率问题，没有展开对象，可自行实践），其中“<em title="直译为“用户代理”，但通常不用翻译">userAgent</em>”是一个比较重要的属性。在早期作浏览器判断都是依靠这个属性，不过随着浏览器版本的发展，再用这个属性去区分不同的浏览器已经行不通了。可以可以尝试地在控制台输入这个属性进行观察：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-345.jpg">
		</code>
		<p>通过观察，可以在里面发现一些其它浏览器的信息，如“Mozilla”（FireFox浏览器厂商）和“Safari”（苹果浏览器）这些额外的信息，所以想通过它来判断当前浏览器究竟是哪个浏览器是不可能了，但是使用这个属性还是可以用于判断当前的设备是PC端还是移动端的。现在我们通过谷歌开发者工具将当前环境模拟为移动端环境，然后再次在控制内输入navigator.userAgent这个属性观察：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-346.jpg">
		</code>
		<p>通过肉眼对比已经可以发现两端代码的长度是不一样的了，认真对比还会发现里面有些内容被替换了，而且还新增了一些字符，如“iPhone”、“iPhone OS 9_1”、“Mobile”等字符。利用这一点我们可以用来很好地解决一些跨平台的代码兼容性问题，或者开发针对设备的特殊交互效果。</p>
		<p>现在我们利用navigator.userAgent来编写一段用于判断当前环境是否为移动端并且是否是“iPhone”手机的代码：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-347.jpg">
		</code>
		<p>然后我们就几种情况进行测试。</p>
		<p>PC端：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-348.jpg">
		</code>
		<p>iPhone 4：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-349.jpg">
		</code>
		<p>Samsung Note 3：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-350.jpg">
		</code>
		<p>若在PC端判断当前的浏览器厂商也提供了一个属性，就是“navigator.<em>vendor</em>”。虽然这个属性得到了现在主流浏览器的支持，但除了谷歌会返回“Google Inc.”的字符串结果外，其它浏览器目前返回的仍然是一个空字符串（以Google Chrome 57版本同期时段为例），相信以后更多浏览器厂商会加上这个信息。</p>
	</section>
	<!-- 章节练习 -->
	<section class="unitPractice">
		<h3>&lt;章节练习一&gt;</h3>
		<p>1、创建一个含有一个&lt;main&gt;标签的html页面，标签内添加任意文本内容，&lt;head&gt;内包含一个id为“setCSS”的&lt;link&gt;标签；</p>
		<p>2、在根目录下新建一个css文件夹，文件夹内包含三个CSS文件，名称分别为“sytle-large.css”、“style-small.css”和“style-mobile.css”；</p>
		<p>3、当页面分比率宽度大于1366像素，使用样式“sytle-large.css”，分辨率宽度小于1366像素使用样式“style-small.css”，当检测到设备为移动端时，使用样式“style-mobile.css”；</p>
		<p>4、“sytle-large.css”为默认的样式表，大体内容为：&lt;main&gt;宽度为1280像素，标签水平居中，字体大小为16像素，字体为红色；</p>
		<p>5、“style-small.css”大体内容为：&lt;main&gt;宽度为960像素，标签水平居中，字体大小为14像素，字体颜色为蓝色；</p>
		<p>6、“style-mobile.css”大体内容为：&lt;main&gt;宽度为100%，有12个像素的内间距，字体大小为16像素，字体颜色为中灰色。</p>
		<p>页面不需要响应分辨率的变化，能保证页面每次载入时准确执行功能即可。</p>
		<p>&lt;扩展功能&gt;</p>
		<p>在样式表没有确定之前，考虑到网络加载及性能问题，页面上的内容不能显示出来，需要等到确认了样式表再显示出页面内容。</p>
	</section>
	<!-- 页面打印 -->
	<section>
		<h3>window.print()方法</h3>
		<p>在PC端很多网站的《XXX服务条款》或需要用传统笔来填写和签名的表格都会有一个“打印”按钮，用于连接有打印机的设备打印当前的页面。这个时候只需要简单一句代码即可实现，如例：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-351.jpg">
		</code>
		<h4><a href="html-pages/javascript/codeEffect/code-005.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun class="codeEffect" src="html-pages/javascript/codeEffect/code-005.html"></iframe>
		<p>在点击了绑定“print()”按钮之后只需要按照平时页面打印的常规设置即可使用打印机进行打印。这里需要注意的一个小细节是，在打印页面最上方会有两段小的文字，一个是当前电脑上的月份和日期，后面一个是写在HTML的&lt;head&gt;标签里&lt;title&gt;标签内的文本内容，可以根据需要设置。</p>
	</section>
	<!-- 选中的内容 -->
	<section>
		<h3>window.getSelection()方法</h3>
		<p>getSelection()方法返回一个返回一个Selection对象，表示用户现在选中的文本。而用这个方法的toString()方法可以用于返回被选中的文本。我们来通过一个简单的示例来了解该方法的实际运用：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-352.jpg">
		</code>
		<h4><a href="html-pages/javascript/codeEffect/code-006.html" target="_blank">运行效果</a>（请先点击下面的测试窗体，再通过鼠标选中文本观察效果）：</h4>
		<iframe data-iframe-coderun class="codeEffect" src="html-pages/javascript/codeEffect/code-006.html"></iframe>
		<p>示例中使用了一个“<em>onmouseup</em>”事件来激活用户选择文本的操作，该事件触发条件是用户松开鼠标左键的时候。通过我们后面章节学习的“JavaScript事件”可以利用该方法来完成一些有意思的功能，也可以用来简化界面操作，提升用户体验。</p>
	</section>
	<!-- iframe -->
	<section>
		<h3>iframe元素对象</h3>
		<p>之前我们已经多次提到过，&lt;iframe&gt;实质上就是嵌入到页面里的页面，但是原则上它们是两个不相同的页面。也就是说是不能用常规的方法通过在父页面上通过一般的DOM操作去操作&lt;iframe&gt;的元素的。如这样一个例子。</p>
		<p>主页面的代码如下：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-353.jpg">
		</code>
		<p>&lt;iframe&gt;页面的内容如下：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-354.jpg">
		</code>
		<h4><a href="html-pages/javascript/codeEffect/code-007.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun class="codeEffect" src="html-pages/javascript/codeEffect/code-007.html"></iframe>
		<p>通过示例可以发现，&lt;iframe&gt;标签内页面的&lt;div&gt;都没有获取到。其实这个结果也不难猜到，因为&lt;iframe&gt;标签包含页面用的是一个“src”属性，也就是说当前的标签对里面的页面只是一个资源引用，就和&lt;img&gt;标签的“src”属性一个原理。</p>
		<p>在示例的代码中我们使用了ECMAScript 2015（简称ES6）中的“<em>模版字符串</em>”功能来简化代码，上例中的“mainDiv.innerHTML”ES5和ES6写法的对比如下：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-355.jpg">
		</code>
		<p>通过对比可以发发现ES6的写法会简洁很多，管理起来也更加方便，这相当于是原封不动地将HTML代码复制过来就可以用，只需根据需要用“${variate}”替换变量部分即可。随着代码的复杂度增加，这种写法会越来越有优势，现在最新版的主流浏览器都支持这种写法。</p>
		<p>另外，需要解释的一点是，代码里所用的延迟执行函数setTimeout()在这里的作用。因为页面加载的顺序首先是整个文档结构，然后才是资源文件。这和网速比较慢（或资源体积较大）的时候去浏览器一些网站，整个页面以及样式表和脚本文件（页面加载的一些事件已经执行）已经加载完成了，但是里面的图片却还在缓缓地加载是一个道理。也就是说，如果在当前主页面非资源文件一加载完成就直接用JS去访问资源文件是访问不到的，这个时候资源文件尚未开始加载，然而用window.onload事件又经常会出现一些“不可把控”的问题（但在绝大多数时候还是最好的选择），所以这里才采用了这个事件来处理。当然，这里用setTimeout(function() {...},100)延迟加载只是为了简化逻辑，在实际项目中并不推荐使用，因为你永远不知道主页面加载所需要的时间，如果主页面还没有加载完成，子页面是不会开始加载的。</p>
		<p>说了这么多，我们的主要问题还是没有解决，就是怎么通过主页面去访问&lt;iframe&gt;标签内的页面，其实可以通过实例化的iframe的Element对象的<em>contentWindow</em>属性和<em>contentDocument</em>属性去做这这件事。</p>
		<p>contentWindow属性获得iframe节点包含的window对象，而contentDocument属性获得得iframe节点包含的document对象。子页面的不变，我们修改一下主页面的代码，再观察输出结果。</p>
		<p>主页面的代码经过修改后如下：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-356.jpg">
		</code>
		<h4><a href="html-pages/javascript/codeEffect/code-008.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun class="codeEffect" src="html-pages/javascript/codeEffect/code-008.html"></iframe>
		<p>这样一来我们就可以通过主页面去访问&lt;iframe&gt;标签内页面的window或document对象了，倘若iframe内还继续包含iframe页面的话，只需要链式地继续向下层访问即可。</p>
		<p>既然主页面可以访问子页面，那iframe内的页面也是可以访问父页面的，只需要用“<em>window.parent</em>”即可，我们来看下面的例子。</p>
		<p>主页面的内容：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-357.jpg">
		</code>
		<p>iframe页面的内容：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-358.jpg">
		</code>
		<h4><a href="html-pages/javascript/codeEffect/code-009.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun class="codeEffect" src="html-pages/javascript/codeEffect/code-009.html"></iframe>
		<p>需要指出的是，如果当前页面已经没有“parent”了，那“window.parent”返回的就是它自身。如本来就是需要返回自身，除了直接使用“window”以外，还可以使用“<em>window.self</em>”，关于“self”的内容在本章已经讲解过。另外，如果一个页面内包含多层iframe的话，最内层的iframe页面需要访问，最外层的父级就可以使用“<em>window.top</em>”。</p>
	</section>
	<!-- 章节练习 -->
	<section class="unitPractice">
		<h3>&lt;章节练习二&gt;</h3>
		<p>编写一个包含两个iframe的页面：</p>
		<p>1、第一个iframe页面的内容为三个文本框，三个文本框已经有值，分别是：“战斗暴龙兽”、“终极体”和“战斗龙卷风”；</p>
		<p>2、第二个iframe页面内的内容为“宝贝”、“形态”、“技能”已经一个名为“激活”的按钮；</p>
		<p>3、点击第二个iframe里的按钮，使第二个iframe里面的字段右方对应显示出第一个iframe内三个文本框的内容值。</p>
		<p>&lt;提示1&gt;主页面和iframe涉及到跨域限制，需要通过启动本地服务器进行测试</p>
		<p>&lt;提示2&gt;可以结合“parent”和“frames[n]”来解决这个问题</p>
	</section>
	<!-- 延时执行函数 -->
	<section>
		<h3>延时函数setTimeout()</h3>
		<p>在一个稍微复杂一点的项目中，很多时候我们是需要控制代码执行的时间的，也就是需要控制代码执行的顺序。单纯地调整代码执行的位置很多时候在满满都是各种回调函数的程序里面是行不通的,这个时候我们就需要用到延时函数又称“延迟函数”）“<em>setTimeout()</em>”。</p>
		<p>这个函数包含两个参数，第一个参数接收一个function数据类型的值（也可以是“函数名+()”的字符串），第二个参数表示延时执行的时间，单位为“毫秒”。</p>
		<p>这个函数的简单用法我们在课件的很多地方都已经见过了，本节主要讲解的是这个函数的几种用法和它的一些简单的特性。</p>
		<p>第一种用法就是直接将需要执行的函数的名称作为第一个参数，或写成需要执行的“函数名+()”的字符串形式，如下：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-359.jpg">
		</code>
		<p>如果需要执行的函数没有参数，可以采用上例的第一种写法，如果需要带参数的话，就需要采用上例的第二种写法，但是采用上例的第二种写法需要注意，带进括号的参数也属于字符串的一部分，不能使用字符串拼接。</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-360.jpg">
		</code>
		<p>关于setTimeout()函数的第二种写法就是直接将第一个参数设为一个匿名函数，然后再在里面编写语句或调用方法。在功能比较复杂的项目中，这种写法更被推崇。因为这样可以让一个延时函数执行多个函数或方法，一定程度上降低了代码的耦合度，参数的配置也更符合我们平时开发的习惯。</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-361.jpg">
		</code>
		<h4><a href="html-pages/javascript/codeEffect/code-010.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun class="codeEffect" src="html-pages/javascript/codeEffect/code-010.html"></iframe>
		<p>在实际开发中还有一种需求，就是需要延时执行的代码因为某种条件的成立需要取消执行，这个时候就可以用到“与之配套”的“<em>clearTimeout()</em>函数”，它可以清除正处于延时过程中的函数，使之不再执行。它的参数为延时函数的实例化对象（变量）名称。也就是说，哪怕将setTimeout()函数赋给一个变量它也是也能执行的。我们来看下面的例子：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-362.jpg">
		</code>
		<h4><a href="html-pages/javascript/codeEffect/code-011.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun class="codeEffect" src="html-pages/javascript/codeEffect/code-011.html"></iframe>
		<p>对于将一个延时函数赋给一个变量的方式需要说明一点，就是这样的做法不需要任何事件去触发，它也是会执行的。所以不要企图将一个延时函数存为一个变量，待需要的时候才去调用这个变量。</p>
	</section>
	<!-- 定时执行函数 -->
	<section>
		<h3>定时函数setInterval()</h3>
		<p>该函数的代码结构及大体功能和setTimeout()函数一样，但区别是该函数会根据设置的第二个参数的毫秒数作为间隔来<em>重复执行</em>，它同样有一个配套的中止函数方法“<em>clearInterval()</em>”。</p>
		<p>我们将上一节setTimeout()函数的最后一个例子稍作修改来学习setInterval()函数的使用方法：</p>
		<code class="indent">
			<img src="img/code/jscode/code-js-363.jpg">
		</code>
		<h4><a href="html-pages/javascript/codeEffect/code-012.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun class="codeEffect" src="html-pages/javascript/codeEffect/code-012.html"></iframe>
		<p>定时执行函数在现在的项目中有有非常多的用处，基本每个项目都会有所涉及，常用于开发如图片轮播，倒计时，定时数据更新，计时关闭跳转页面等功能，务必要熟悉其使用方法。</p>
	</section>
	<!-- 章节练习 -->
	<section class="unitPractice">
		<h3>&lt;章节练习三&gt;</h3>
		<p>制作一个简单的banner图片轮播效果：</p>
		<p>1、图片必须占满当前浏览器窗口的100%宽度；</p>
		<p>2、图片的高度自定（建议在320~560像素之间）；</p>
		<p>3、图片的必须要维持原图比例；</p>
		<p>4、图片为元素的背景图片（不使用&lt;img&gt;）；</p>
		<p>5、图片数量大于2张。</p>
		<p>&lt;注&gt;可以不需要切换过程的动画。</p>
	</section>
</root>






