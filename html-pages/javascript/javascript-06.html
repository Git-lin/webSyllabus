<root data-root="数据类型--内置对象">
    <!-- 数组详解 -->
    <section class="mt0">
        <h3>数组详解</h3>
        <p>数组是有序排列的一组值的集合，这些值被包含在一对方括号内，里面的这些值称作数组元素、数组项、数组成员等。每个数组内的值都会有一个“键名”，这些键名其实就是一个从0开始依次计数的下标，每个数组都会有一个“<em>length</em>”属性，表示数组元素的个数，所以数组内元素最大的下标值应该是“length - 1”。</p>
        <p>数组内的值可以是JavaScript允许的任何类型的值，甚至可以是数组自身，像这样数组内包含另外一个数组的数组被称作“二维数组”，如果数组内的数组任然继续包含数组，这样的数组就会形成“多维数组”。数组的基本表现形式如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-103.jpg">
        </code>
        <p>数组虽然有很多独立的特性，但它的数据类型仍然为对象型（object），它仍旧具有对象的诸多特点：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-104.jpg">
        </code>
        <p>在之前的JavaScript循环语句“for-in循环遍历”的一个章节中，我们讲到过，该循环语句能够遍历出一个对象的“键名”和“键值”，除此之外，我们还可以用“Object”的“<em>keys()</em>”属性方法去获取一个数组的“键名”，即元素下标：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-105.jpg">
        </code>
        <p>通过输出结果可以发现，该方法返回的结果仍旧是一个数组，但数组内的元素已经变成了数组元素下标的字符串。其实是因为JavaScript语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。</p>
        <p>像平时我们通过数组元素的下标来获取到的数组元素内容，诸如：arr[0]、arr[3]、arr[5]等，其实在程序内部已经被转换成了：arr[<em>"0"</em>]、arr[<em>"3"</em>]、arr[<em>"5"</em>]这样的形式。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-106.jpg">
        </code>
        <p>对于数组元素而言，它是可以先声明后赋值的，主要有两种声明方式：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-107.jpg">
        </code>
        <p>数组的赋值和普通变量的赋值有些区别，就是需要“对位赋值”，即通过数组元素下标对相应的位置进行赋值（哪怕这个位置在数组内还不存在）。这两种赋值语句我们都故意遗漏了数组元素下标[2]，即数组内的第3个元素，但是在产生的数组中却仍旧保留了这一个元素的位置，只不过它的值为undefined而已。在上面两种数组赋值语句当中，我们更推荐使用后一种。</p>
        <p>需要注意的是，数组虽然也是对象，但实际上下面这些获取数组元素的方法都是不合法的。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-108.jpg">
        </code>
        <p>JavaScript使用一个32位整数来保存数组的元素个数。这意味着，数组成员最多只有4294967295个（2<sup>32</sup> - 1）个，也就是说length属性的最大值就是4294967295。但在绝大多数的应用场景中，这样的数量已经足够了。另外，length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-109.jpg">
        </code>
        <p>通过上面的示例可以发现，数组中本来应该是5个元素。第一次获取到的数组长度也是5，当我们手动的将“length”属性的值赋成3之后，原来的数组成员从末尾开始减少了两个，变成了剩余的前3个数组元素。也就是说，对于数组而言“length”属性是“<em>可读写</em>”的<em>动态属性</em>。利用这一特性，我们可以达到一个删除数组元素的效果，也就是将“length”属性的值设置为0即可。同理，若一个数组中只有3个元素，这个时候将数“length”属性设置为5，那这个数组的第4位（下标[3]）和第5位（下标[4]）的值都将是undefined。</p>
        <p>对于设置数组的“length”属性需要明白的一个常识就是，该属性不能设置负数值，也不能设置大于2<sup>32</sup> - 1的值，更不能设置除数值型以外的值，否则程序会报错。</p>
        <p>检查某个键名是否存在的运算符<em>in</em>，适用于对象，也适用于数组。该运算符用于检测数组元素的某个位置是否存在元素，返回的是一个布尔值。当通过下标访问的这个位置的值为undefined或该位置不存在，那么它返回的值就为false，否则就为true。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-110.jpg">
        </code>
        <p>需要在这里进行补充说明的是，上例中下标为1和3的地方没有值，称作“<em>空位</em>（hole）”，它返回的值为undefined，但仍然会被计入数组的长度属性“length”中。而length的值是由数组中最后一个元素的下标+1决定的，我们看做这样一个实验来进行应证：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-111.jpg">
        </code>
        <p>针对这样的情况，需要进行一个额外的说明，就是“for-in循环遍历”和“Object.keys()”方法运行的原理都类似于一个单进程的指针，所以数组中的空位（即值为undefined的数组元素）都会被跳过，但通过“length”属性去进行“for循环”的时候，这些空位都不会被跳过。</p>
    </section>
    <!-- 数组操作 -->
    <section>
        <h3>数组操作</h3>
        <p>对于数组，之前我们已经谈到过，虽然它有自己的一套格式，也有自己一套独立的方法，但在JavaScript里，它仍然只是一个object的类型（可以通过类型判断输出方法typeof()得出），若要判断一个值是否为数组，可以使用“Array.isArray()”方法来进行判断，它的返回值是一个布尔值，true表示是一个数组，否者返回false。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-112.jpg">
        </code>
        <p>数组作为JavaScript的内置对象（这区别于包装对象），自然拥有一些自己的方法，有些方法是各类型的对象（包括包装对象）通用的，有些是它独有的，下面我们就来对它的这些方法进行讲解说明。</p>
        <dl class="attrExplain">
            <dt>valueOf()和toString()方法</dt>
            <dd>valueOf()方法用于返回对象本身的值，这是各种数据类型对象的通用方法，toString()方法可以将值转化成一个字符串，这和String()方法的作用是一样的，同样为一个通用的方法。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-113.jpg">
                </code>
            </dd>

            <dt>push()方法</dt>
            <dd>push()方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度，该方法会改变原数组。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-114.jpg">
                </code>
            </dd>
            <dd>这相当于：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-115.jpg">
                </code>
            </dd>
            <dd>但显然用push()方法的操作会安全一些，也更加的直观渐变，因为这样我们甚至不需要知道数组的“length”为多少，只要使用这个方法，新添加的数组元素都会出现在数组末尾，“length”属性也会随之变化。但在涉及到多个数组拼接的情况，使用concat()方法（使用该方法需要定义一个空数组作为临时变量）会更加简便一些，因为直接用push()方法，在参数内设置另外需要拼接的数组，得到的结果是原始数组包含了另外两个数组（不是拼接关系）。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-116.jpg">
                </code>
            </dd>
            <dd>如上例：愿意是要通过push()方法去拼接数组得一个完整的一维数组，但得到的却是一个二维数组。其实，数组的<em>原型类</em>内的push()方法内还内置了另外一个方法，就是“<em>apply()</em>”方法，使用方法如下例：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-117.jpg">
                </code>
            </dd>
            <dd>和使用concat()方法相比，这个方法一次只能拼接一个数组，也就是说该方法内只能接受两个参数，为两个需要进行拼接的数组，当写成上例中的第二种形式，参数内仍然需要包含自身，否则无法达到期望的结果，如下例。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-118.jpg">
                </code>
            </dd>
            <dd>另外，还有一定需要注意的是，和使用concat()方法相比，push()方法会改变原有数组，而concat()方法不会改变原有数组。</dd>

            <dt>pop()方法</dt>
            <dd>该方法的使用方式和push()基本一样，但它的作用是<em>删除</em>数组的<em>最后一个元素</em>，并返回该数组元素。也就是说该方法一次只能删除一个，不能删除多个，任何参数对于它来讲都是无效的，会被忽略。该方法同样会改变原数组。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-119.jpg">
                </code>
            </dd>

            <dt>shift()方法</dt>
            <dd>该方法的使用和pop()方法类似，它的作用是删除数组中的<em>第一个元素</em>，并返回该数组元素。仍然一次只能删除一个，参数对它无效。该方法同样会改变原数组。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-120.jpg">
                </code>
            </dd>

            <dt>unshift()方法</dt>
            <dd>该方法的使用和push()方法类似，它的作用是在数组的<em>开始位置插入</em>或<em>添加</em>（已有数组称插入，空数组称添加，）一个新的元素，并返回该数组长度。该方法同样会改变原数组。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-121.jpg">
                </code>
            </dd>

            <dt>reverse()方法</dt>
            <dd>该方法的作用是将已有数组倒序排列，并返回改变后的数组。该方法同样会改变原数组。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-122.jpg">
                </code>
            </dd>

            <dt>slice()方法</dt>
            <dd>该方法用于提取原数组的一部分，返回一个新数组，原数组不变。它的第一个参数为起始位置（从下标0开始），第二个参数为终止位置（不包括该位置）。如果省略第二个参数，则一直返回到原数组的最后一个成员。这和之前的字符串操作slice()方法非常类似。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-123.jpg">
                </code>
            </dd>
            <dd>除此之外，该方法还可以利用原型类中的“call()”方法将一个<em>类似数组</em>转化成真正的数组：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-124.jpg">
                </code>
            </dd>

            <dt>splice()方法</dt>
            <dd>该方法用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。该方法中的第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-125.jpg">
                </code>
            </dd>
            <dd>另外，该方法的第一个参数可以为负数（但是第二个不能，因为它表示长度），表示从数组末端开始计数，开始计数的值为“-1”。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-126.jpg">
                </code>
            </dd>
            <dd>利用该方法的原理可以达到向指定位置插入数组元素的效果。第一个参数仍然是表示开始下标，第二个参数设为0，这样后续设置的参数就会出现在第一个参数下标位置之后：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-127.jpg">
                </code>
            </dd>
            <dd>以上例为参考，如果想插入多个元素，只需要在第3个参数后继续设置参数即可。</dd>
            <dd>和以往的数组操作一样，该方法同样可以省略第二个参数，这样一来删除的数组就会从给定的参数位置开始一直删除到末尾。通过获取该方法返回的值和原数组，达到了一个“分割”数组的目的。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-128.jpg">
                </code>
            </dd>

            <dt>sort()方法</dt>
            <dd>该方法对数组成员进行排序，默认是按照<em>ASC II</em>码顺序排序。排序后，原数组将被改变。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-129.jpg">
                </code>
            </dd>
            <dd>该方法通过和“reverse()”方法配合，可以实现一个简单的升序、降序排列的功能。但若要实现一个稍微复杂一点的排序，如对数组元素是对象的数组进行排序，这个方法能否办到呢，我们先来做这样一个尝试，让数组元素对象按照产品的价格进行排序。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-130.jpg">
                </code>
            </dd>
            <dd>通过访问元素组下标可以发现，素组内这三个对象的位置完全没有发生改变。其实要实现这个需求也是有办法的，就是需要给“sort()”方法配置一个函数作为参数来实现。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-131.jpg">
                </code>
            </dd>

            <dt>map()方法</dt>
            <dd>该方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。该方法不会改变原来的数组。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-132.jpg">
                </code>
            </dd>
            <dd>上例中，map()方法内有一个匿名函数，函数内有一个参数“ele”，这个参数的名称是自定义的（只要不是关键字和保留字），这个参数在函数运行的时候通过一次内部的遍历指向数组内对应的元素。我们可以通过在外部声明一个计数器变量来证明这一点。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-133.jpg">
                </code>
            </dd>
            <dd>通过上例可以发现，计数器的值由0变成了3，这说明该函数实际上在map()方法的内部执行了3次，而这个函数执行的次数正是由当前的数组元素的长度“length”属性决定的（也有特殊情况，后续会进行说明）。</dd>
            <dd>map()方法内的函数，最多可以接受3个参数。第1个，就是上面例子中出现的参数，它表示数组内每个元素的本身；第2个，表示数组内元素的下标位置；第3个，表示数组本身。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-134.jpg">
                </code>
            </dd>
            <dd>现在看到map()方法执行后返回的值可能会有些困惑，为什么会是[4,5,6]?那是因为push()方法在执行后返回的值是数组当前的长度（unshift()方法也是一样的），通过因为当前数组元素有3个，也就是说这个push()方法会在数组内被执行三次，三次运行后也分别返回了当前数组的长度，而这三次值的返回又组成了一个新的数组（当若这个数组没有用变量存储，或参与到某个表达式中是没有意义的）。而元素组却发生了改变，输出了6个数组元素长度的新数组。当然让这个数组发生改变的并不是map()方法，而是在该方法函数内的push()方法产生的效果（push()方法会改变原始数组）。</dd>
            <dd>该方法和“for-in遍历循环”语句有一个相似之处，即当数组元素中存在空位的时候，该函数是不会去执行的，但只要有明文的值，哪怕是遇到undefined、null、NaN等特殊的“无值”的值，该方法仍然能够执行。我们来看这样一个例子就明白了。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-135.jpg">
                </code>
            </dd>

            <dt>forEach()方法</dt>
            <dd>该方法与map()方法很相似，也是遍历数组的所有成员元素，执行某种操作，但是forEach()方法一般不返回值，只用来操作数据。如果需要有返回值，一般使用map()方法。forEach()方法的参数与map()方法一致，也是一个函数，数组的所有元素会依次执行该函数。它接受三个参数，分别是当前位置的值、当前位置的下标和整个数组。</dd>
            <dd>forEach()方法的参数与map()方法一致，也是一个函数，数组的所有成员元素会依次执行该函数。它接受三个参数，分别是当前位置的元素值、当前位置的下标和整个数组。函数内三个参数的使用方法和map()基本上一致，我们先举例一个函数内只带一个参数的情况。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-136.jpg">
                </code>
            </dd>
            <dd>上例中函数内的“console.log()”方法得到执行，但关键字“return”后续的内容却没有生效，说明forEach()方法是不会执行返回值操作的。另外，该方法可以有第二个参数（并不是值函数内部的参数，而是指forEach()方法本身的参数），第二个参数用于“告诉”函数内部的“this”关键字的指向。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-137.jpg">
                </code>
            </dd>

            <dt>filter()方法</dt>
            <dd>从方法名来看该方法的主要作用是<em>过滤</em>，它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-138.jpg">
                </code>
            </dd>
            <dd>和之前的map()和forEach()方法一样，该方法的函数仍旧支持3个参数，参数位和之前的这两个方法也是一样的，分别表示：数组元素、元素下标和原数组。但要同时使用三个函数内参数的例子并不好举，这里先通过一个抽象的例子来表示用法，实际开发中可以根据需要灵活选取。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-139.jpg">
                </code>
            </dd>

            <dt>some()和every()方法</dt>
            <dd>这两个方法用来判断数组成员是否符合某种条件。它们接受一个函数作为参数，所有数组成员元素依次执行该函数，返回一个布尔值。它们的函数接受三个参数，依次是数组元素、元素下标和原数组。</dd>
            <dd>some()方法是只要有一个数组成员的返回值是true，则整个some()方法的返回值就是true，否则返回false。这理解起来和逻辑运算符或“||”比较相似。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-140.jpg">
                </code>
            </dd>
            <dd>和every()方法是只要有一个数组成员的返回值是false，和every()方法的返回值就是false，否则返回true。这理解起来和逻辑运算符与“&amp;&amp;”比较相似。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-141.jpg">
                </code>
            </dd>

            <dt>reduce()和reduceRight()方法</dt>
            <dd>这两个方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce()方法是从左到右处理，reduceRight()方法则是从右到左，其他完全一样。它们支持最多四个参数，前两个参数是必需配置的，后面的参数可以选配，它们的作用如下：</dd>
            <dd>
                <ul>
                    <li>累积变量，默认为数组当前的第一个数组元素</li>
                    <li>当前变量，默认为数组当前的第二个数组元素</li>
                    <li>当前数组元素的下标位置</li>
                    <li>原数组</li>
                </ul>
            </dd>
            <dd>由于这两个方法的原理完全一样，只是方向不同，所以这里我们暂时只拿reduce()举例：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-142.jpg">
                </code>
            </dd>
            <dd>简单地从参数和返回的表达式来看，可能一时无法看透该方法的运行原理，我们再拿一个简单的例子来分析说明：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-143.jpg">
                </code>
            </dd>
            <dd>这两个方法一般在做数据统计的时候比较常用，通常用来统计如“总成绩”、“总收入/支出”或“积分”等内容。如果，在某个页面/应用内该方法会大量使用，这个时候就可以通过数组的原型类把它封装成一个方法，以供随时调用。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-144.jpg">
                </code>
            </dd>
            <dd>数组的原型类方法内部有个关键字“this”，和我们之前讲到前几个方法一样，它们都可以拥有第二个参数，用于限定this指向的对象。这里的this的作用就是，谁调用该方法，这个this就指向谁。如上例：“income”数组在调用方法“tatal()”时，this就是指“income”。“expend”数组在调用方法“tatal()”时，this就是指“expend”。</dd>
            <dd>通过原型类定义的一个方法，和直接用关键字“function”创建的函数的一个显著区别在于，原型类的参数在原型内就已经定义好，只要了解其功能，就可以在多处地方任意使用，而function需要根据使用场景不同配置不同的参数。所以相对function来说原型类在使用的时候的简便性和易用性都会高上一些。</dd>

            <dt>indexOf()和lastIndexOf()方法</dt>
            <dd>indexOf()方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。该方法和字符串中的indexOf()方法基本类似。</dd>
            <dd>lastIndexOf()方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。该方法和字符串中的indexOf()方法基本类似。</dd>
            <dd>这两个方法执行的原理完全一样，只是方向不一样，所以这里我们就只以indexOf()方法举例。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-145.jpg">
                </code>
            </dd>
            <dd>根据方法的执行原理，若要使用在条件判断语句内需要判断的值需要注意，不是数值0，也不是布尔值true或false，而是数值“-1”。</dd>
            <dd>另外，这两个方法还能配置第二个参数，表示开始检索的位置。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-146.jpg">
                </code>
            </dd>

            <dt>链式使用</dt>
            <dd>在数组的方法中，除了可以实现数组操作方法的嵌套，若所用方法返回的仍旧是一个数组的话，还可以使用<em>方法链</em>来完成一个特定的功能。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-147.jpg">
                </code>
            </dd>
            <dd>在有一些需求复杂的程序中，我们很难通过一个简单的数组操作方法去完成一项特定的功能，只有通过这些数组的一个个操作才能完成指定需求。但若每个返回结果都用一个变量去存储，声明很多变量，不仅代码可阅读性有所降低，程序的性能降低，需要大量的命名有的时候也是一个麻烦。这个时候，如果熟悉每种数组操作的返回结果，通过链式的方法去执行数组操作，那对于代码的优化来讲将是一个不错的帮助。</dd>
        </dl>
    </section>
    <!-- 章节练习 -->
    <section class="unitPractice">
        <h3>&lt;章节练习一&gt;</h3>
        <p>通过链式数组操作语法，完成有以下班级成绩数组的显示需求：</p>
        <p>[48,63,55,92,96,77,82,69,86,83,16,72,90,81,88,80,73,66]</p>
        <p>1、成绩需要由高到低排列；</p>
        <p>2、需要及格（包括60分）到90分以下（不包括90分）的区段的成绩；</p>
        <p>3、获取到及格到90分以下区段分数的总成绩。</p>
    </section>
    <!-- 对象详解 -->
    <section>
        <h3>对象详解</h3>
        <p>对象（object）是JavaScript的核心概念，也是最重要的数据类型。JavaScript的所有数据都可以被视为对象。简单说，所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value，亦称属性名值对、成员等）构成。下面展示了两种对象的书写方法：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-148.jpg">
        </code>
        <p>两种写法的引号可为双引号，也可以为单引号。若有多个键值对，每个键值对后面都需要加上英文逗号“,”作为分割符，否则程序会报错，最后一个键值对后方可加，也可不加。第一种写法为常用写法，是程序中最常用的写法，第二种写法叫做严格写法，这种严格模式的写法通常用于<em>JSON</em>文件的编写。但实际上第二种写法在某些情况下是一种必要手段，就是当属性名（键名）为数字外加其它内容等一些非严格命名模式的时候。如果为数字（包括科学计数法、浮点数、进制数），数字会被自动转换成字符串，如果是出现数字+其它字母、字母+空格+字母、字母+其它符号等的时候，就必须要手动加上引号了，否则程序会报错。 </p>
        <code class="indent">
            <img src="img/code/jscode/code-js-149.jpg">
        </code>
        <p>其实哪怕就是从我们编辑器（示例采用编辑器为“Adobe Brackets”）的代码颜色来看，第二种写法也明显不符合语法规范，键名出现了颜色不正常的现象，放置于控制台运行，可以更加清晰地看到运行的结果。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-150.jpg">
        </code>
        <p>另外，JavaScript内的关键字和保留字也可以作为属性名，并且不需要加上引号也能正常使用。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-151.jpg">
        </code>
        <p>对象允许的值可以是JavaScript种的任何类型（6种类型），可以是一个表达式，也可以为一个函数，当一个属性的值为一个函数的时候，通常把这个对象的属性称作“方法”（如操作字符串或数组的各种方法），它可以像使用其它对象内的属性一样使用，但是需要在后方加上一对括号。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-152.jpg">
        </code>
        <p>定义了这样一个包含了对象之后，就可以在程序中使用了（作用域仍然只分全局和函数的作用域）。为了直观展现运行结果，我们依次对上面定义的这个对象的各个属性在控制台运行程序后进行访问或使用。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-153.jpg">
        </code>
        <p>可以发现，我们现在对象中定义属性直接可以被像一个变量一样使用了，只不过是使用的时候多了一个点“.”，将普通变量的“=”号换成了“:”号而已，除此之外基本没有任何不同。</p>
        <p>当然，和作为数组形式展现的对象一样，普通对象也可以先声明再设置属性。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-154.jpg">
        </code>
        <p>根据对象的这个特性，我们就可以根据当前的使用场景（如满足一定的条件语句后），动态地为对象添加需要的属性了。但需要注意的是，对象数据类型是引用型数据，也就是说当一个对象赋值给另外一个变量后，它们指向的内存地址是相同的（这和数组一样），如例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-155.jpg">
        </code>
        <p>但是有一点需要注意，也就是任何一个对象取消对值的引用，之前已经引用过该值的对象是的值仍旧会保留。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-156.jpg">
        </code>
        <p>对于对象属性的读取，主要有两种方式，一种是“对象.属性”的格式，另一种是“对象[属性]”的格式。但是这两种方法在有些情况下并非等价的，就是如果属性是<em>数值型</em>的话不能采用第一种加“.”的形式，只能写成第二种形式。如果属性是<em>字符串</em>的话，两种形式都可以使用，但是使用第二种的话需要再在方括号内加上一对引号，否则会被视作一个变量。正确示例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-157.jpg">
        </code>
        <p>错误示例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-158.jpg">
        </code>
        <p>这两种访问属性的方法的区别还不止于此，通过“.”访问的属性不能是变量，不能是运算表达式，但是用“[attr]”这种方式可以接受变量，亦可以接受运算表达式。在对象的属性不是很确定的时候，用“[variable]”作为一个对象的载体是一个非常不错的选择。</p>
        <p>比如现在，我们在一个虚拟出来的“书籍”对象内配置一个简单的方法，用于输出一个对象内指定属性的值，就可以这样去写：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-159.jpg">
        </code>
        <p>在控制台中进行传参调用后的结果如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-160.jpg">
        </code>
        <p>如果讲上例中的“book[link]”换成“book.link”的话，该功能是无法完成的，无论配置任何参数返回的都将是undefined。正是因为使用“[]”的形式有接收变量的作用，这为我们以后封装具有对象的函数提供了便利。但若所使用对象不涉及到变量，还是建议使用“.”的形式对属性访问更加便捷高效。</p>
        <p>对于使用“[]”访问对象的属性还有一点需要补充，就是若对象是一个数组的话还可以使用<em>运算表达式</em>去访问数组内的内容。这对于实现一些复杂的需求会有一定程度的帮助，我们看来这几个简单例子：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-161.jpg">
        </code>
        <p>示例中最后三个完全一样的表达式“arr[Math.round(Math.random() * (arr.length - 1))]”得出的结果却不相同，是因为里面用到了<em>Math</em>函数内的取0~1之间的随机数方法<em>random()</em>，外层用该函数的“四舍五入”方法<em>round()</em>保证取出的数是整数。整个“[]”取出的数为整个数组下标从0到length-1（最大下标）之间的随机下标。</p>
        <p>和查看所有数组的下标一样，利用<em>Object.keys(obj)</em>方法可以查看对象所有的属性名，返回的结果是一个数组。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-162.jpg">
        </code>
        <p>通过上面的示例可以发现，利用这个内置对象Object的keys()方法，我们可以“玩出”非常多的花样，不仅可以像数组那样通过“length”属性（对象本身是没有length这个属性的）获取到对象的属性个数，还可以像数组那样，通过下标去访问对象内的属性值。单是获取对象属性个数这一点来讲，这个方法会被我们用“计数器”+“for-in遍历”要显得“干净”得多。</p>
        <p>对于数据操作来讲，无非就是四种操作“增、删、改、查”。对于对象来讲，“增”就是为一个对象新增一个之前不存在的属性名，然后进行赋值；“改”就是对对象已经存在的属性名进行从新赋值，达到一个修改原始对象的效果；而“查”就是简单地通过对象的属性名访问即可（当然也可以通过对“[]”传变量实现访问）。这些我们之前都讲解过，但对于“<em>删</em>”来讲稍微有些特殊，需要用到关键字“<em>delete</em>”进行操作，为了说明问题，我们还是对这些操作进行回顾并在其中列出“delete”的使用方式。原数组如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-163.jpg">
        </code>
        <dl class="attrExplain">
            <dt>增</dt>
            <dd>新增一个“出版社”属性。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-164.jpg">
                </code>
            </dd>

            <dt>删</dt>
            <dd>删除“出版装订类型”属性。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-165.jpg">
                </code>
            </dd>
            <dd>注意，该方法在执行成功后会返回一个布尔值<em>true</em>，只有当正在删除的对象属性不存在或不能删除（如继承的属性：toString、valueOf等）时才会返回false值。</dd>

            <dt>改</dt>
            <dd>修改“图书页数”和“出版时间”属性。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-166.jpg">
                </code>
            </dd>

            <dt>查</dt>
            <dd>查询“书名”、“作者”和“页数”属性。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-167.jpg">
                </code>
            </dd>
        </dl>
        <p>当不知一个对象的属性是否声明过，使用<em>in</em>运算符来进行判断是再好不过的选择了（选用对象仍是之前的“书籍”）。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-168.jpg">
        </code>
    </section>
    <!-- 对象操作 -->
    <section>
        <h3>对象操作</h3>
        <p>JavaScript原生提供一个Object对象，所有其他对象都继承自这个对象。Object本身也是一个构造函数，可以直接通过它来生成新对象。基本语法为：</p>
        <p><em>var obj = new Object();</em></p>
        <p>对象型数据有一个比较有趣的特点就是它具有<em>原型类</em>（prototype），任何对象都能通过原型类来拓展自己的功能，这一点，我们在“数组操作”一节中的“数组求和”功能里就已经见识到了。数组之所以可以通过原型类来扩展自己的功能，是因为数组本身也属于“对象”。我们再来看一个关于内置对象通过原型类扩展自己的<em>方法</em>的简单例子，基本代码如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-169.jpg">
        </code>
        <p>在控制台中被调用后的返回值结果如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-170.jpg">
        </code>
        <p>上面的代码中，首先是给内置对象Object添加了一个原型类的方法，该方法内“keys()”方法的作用我们在上一节“对象详解”中已经学习过，是用于讲对象的属性名进行返回，然后形成一个数组。而在该方法之前有一个关键字<em>this</em>，它表示使用该原型方法的对象的本身，如“obj1”在使用“showAttr()”方法时，“this”指的就是“obj1”。</p>
        <p>showAttr()这个方法是我们的一个自定义名称，我们可以根据需要，给原型类添加任意的自定义方法。这样一来，以后所有的新建对象都可以使用这些方法，大大地减少了代码量和也减少了对方法参数的配置。可以把原型类内我们自定义新建的方法理解为对象的公共方法，任何对象在同一个作用域内都可以对其进行使用。</p>
        <p>其实，也并非只有数组（Array）和普通对象（Object）才是所谓的“对象”，可以将JavaScript任何允许的数据类型放置于<em>Object()</em>方法的参数内都可以转换成为一个对象，这样的对象称作“<em title="变量的赋值操作是对值的引用">包装对象</em>”，这在我们上一章的课程内。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-171.jpg">
        </code>
        <p>但如果，使用Object()方法为参数内配置一个JavaScript的“<em title="变量的赋值操作是对内存地址的引用">内置对象</em>”，那返回的就是该对象本身。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-172.jpg">
        </code>
        <p>为了证明这一点，我们对刚才的这些内置对象做了一次“严格等于”运算符的比较运算。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-173.jpg">
        </code>
        <p>像“对象”这种复合型的值，通过普通方式来判断它是否为一个“内置对象”比较困难，像判断数值和判断数组都有类似于“isNaN()”和“isArray()”这样的方法，但是对象却没有，直接使用我们猜测存在的方法“isObject()”只会是这种下场：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-174.jpg">
        </code>
        <p>但好消息是，这并不妨碍我们自己根据对象已经暴露的一些特性给它创建一个“原生方法”：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-175.jpg">
        </code>
        <p>调用我们自定义的原型类方法后，在控制台中的返回值结果分别如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-176.jpg">
        </code>
        <p>上一章我们在讲解“字符串操作”的时候提到过一个方法“<em>String()</em>”，它可以将任何类型的数据都转换成字符串，但在转换数组和对象时，出现了点特殊情况（可以自行回顾该章节的内容），即其它类型的数据都变成了和原始声明时基本一样的数据，只是加上了引号，而对象出现的结果却是“<em>[object Object]</em>”，其实这里的第一个值表示该值是一个对象（之前提到过，JavaScript中任何值都可以成为对象），第二个值为该类型值的构造函数（有些对象是通过包装而来的）。当然，除了将需要转换字符串的内容放置于String()方法的参数内，还能通过对象属性的方式来使用该方法，它的写法是“toString()”，不需要配置参数。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-177.jpg">
        </code>
        <p>可以从运行结果中看出来，这和我们上次使用的“String()”方法得出的结果完全一样。但其实作为一个对象的属性的“toString()”方法来讲自然会有一些不同的。它其实是对象原型类的一个方法，语法如下：</p>
        <p><em>Object.prototype.toString</em></p>
        <p>既然是原型类的方法，那很多时候它们还有自己的“<em title="内部的实现相当于一个函数闭包">子方法</em>”，如“<em>call()</em>”方法。基本使用方法如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-178.jpg">
        </code>
        <p>通过示例可以发现，除了特殊的自身不等于自身的“NaN”值以外，其它的值都在返回结果的第二个值中表现出了自己真实的“值类型”，这最大程度地弥补了“typeof()”方法（通常情况下，typeof()方法还是首选）的不足。但是单是发现了这个原型方法的特性还没有什么用，要真正地将该特性利用起来，还得我们自己写成一个方法函数。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-179.jpg">
        </code>
        <p>通过在控制台中调用该函数进行测试：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-180.jpg">
        </code>
        <p>经过简单测试，自定义的方法完美地实现了数组类型的精确判定。另外，上例中出现了一个陌生的方法啊，已经在注释内进行说明了，就是将英文转换成<em>小写字母</em>的方法“<em>toLowerCase()</em>”，和将英文转换为<em>大写字母</em>的方法“<em>toUpperCase()</em>”，但这在中文网站或应用内并不常用，只需明白有这两个方法（实际上还有个每个单词首字符都大写的方法），需要使用时再进行查询即可。</p>
        <p>明白了这些特性后，我们还可以发挥自己的想象能力玩一些更为“高端的操作”，如：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-181.jpg">
        </code>
        <p>通过在控制台中调用自定义的对象的方法进行测试：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-182.jpg">
        </code>
    </section>
</root>






