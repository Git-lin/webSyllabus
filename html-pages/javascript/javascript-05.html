<root data-root="数据类型详解">
    <!-- 数值型详解 -->
    <section class="mt0">
        <h3>数值型详解</h3>
        <p>在JavaScript中，所有的数字都是以64位浮点数的形式存储的，就算是表面上看到的浮点数，实质上它也是一个浮点数。如“1”和“1.0”完全是同一个数，他们的“1 === 1.0”会返回“true”的布尔值（在其它很多编程于语言里这样的表达式是不成立的）。其实在JavaScript语言的底层，根本没有整数（其他编程语言是“int”型）这个类型。但有的时候JavaScript的值的计算必须要整数才能完成，JavaScript的做法也只是将它64位的数值转换为32位在进行运算而已。</p>
        <p>但是，浮点数始终是一个不精确的数，在进行浮点数运算的时候会出现一些意料外的情况。比如现在我们拿这几个浮点数在控制台内进行运算输出，观察结果：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-058.jpg">
        </code>
        <p>所以，在进行一些需要高精度的整数计算的时候，最好能对运算数使用保留小数点的方法“<em>toFiexd()</em>”再用对应的十分位数相乘转换回原始计算结果，该方法的括号内需要有一个参数，参数是一个数值型，如“toFiexd(2)”表示计算结果保留两位小数，然后将得出的结果乘以“100”即会得到一个相对精确的整数。</p>
        <p>根据<em title="美国电气电子工程师学会，而“754”表示他们制立的二进位浮点数算术标准">IEEE 754</em>规定，有效数字第一位默认总是1，不保存在64位浮点数之中。在这64位中，第1到第12位表示数值的“指数”，剩余的52位是用二进制表示，也就是说JavaScript的有效数字是一个53位的二进制单位，这意味着JavaScript能精确表示的数值范围在-(2<sup>53</sup>-1)到2(2<sup>53</sup>-1)之间。在JavaScript中对数值求幂（N次方）的函数是“<em>Math.pow(binary,power)</em>”，其中“binary”是指“底数”，函数中的参数意思就是“binary”的“power”次幂（次方），如“Math.pow(5,3)”得出的结果就是25，表示5的3次方。所以，针对上述原理，我们可以算出JavaScript最大能保留的精度数值，写作：Math.pow(2,53)。我们在控制台内做这样一个实验：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-059.jpg">
        </code>
        <p>从上面示例可以看到，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于等于2的53次方的数值，都无法保持精度。而且大于该值位数的值都不能被保存，被会自动神略掉。</p>
        <p>JavaScript还能采用科学计数法来表示一个数值，将数字写在“e”或“E”后方表示指数，如：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-060.jpg">
        </code>
        <p>有两种情况，JavaScript会将一个数值自动转换为科学计数法，一种是小数点前多余21位的数字，另外一种是小数点后的“0”多于5位的情况，如：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-061.jpg">
        </code>
        <p>作为一门计算机语言，JavaScript自然也支持四种基本的进制表示法，它们分别是：十进制、二进制、八进制和十六进制。</p>
        <dl class="attrExplain">
            <dt>十进制</dt>
            <dd>也就是常用是数值，如阿拉伯数字：...-2,-1,0,1,2...（同时也包含每个数字之间的小数）</dd>

            <dt>二进制</dt>
            <dd>需要在数值之前加上<em>前导数</em>：“<em>0b</em>”或“<em>0B</em>”（后面的“b”或“B”是英文字母），且前导数后方的数值不能大于1，或是其它内容，否则浏览器会报错，如：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-062.jpg">
                </code>
            </dd>

            <dt>八进制</dt>
            <dd>需要在数值之前加上前导数：“<em>0o</em>”或“<em>0O</em>”，且前导数后方的数值不能大于7，否则浏览器会报错，或是其它内容，如：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-063.jpg">
                </code>
            </dd>

            <dt>十六进制</dt>
            <dd>需要在数值之前加上前导数：“<em>0x</em>”或“<em>0X</em>”，且前导数后方的数值不能大于f或F（相当于十进制内的15），或是其它内容，否则浏览器会报错，如：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-064.jpg">
                </code>
            </dd>
        </dl>
        <p>在数值型数据中，有一个特殊的存在“<em>NaN</em>”，它表示的是“非数字”（Not a Number），但当用数据类型判断的方法“typeof()”对它进行类型判定时，得出的结果却是“number”。在比较运算符中“NaN == NaN”得出的值却是“false”，如：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-065.jpg">
        </code>
        <p>从控制台中返回的结果可以发现“NaN”基本不和任何类型的数据相等，要判断一个数据的值是否是“NaN”，JavaScript提供了一个方法：<em title="“param”表示参数,英文全称为“Parametric”">isNaN(param)</em>，将需要判断的值或变量作为参数放置于该方法内即可根据返回的值判断该值或变量是否为一个“NaN”，如果返回的值为true，表示值为NaN，如果返回的值为false，那就表示它的值不是NaN，如例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-066.jpg">
        </code>
        <p>可以发现，其实直接对值类型进行判断的情况下，除了数值型（number）以外，返回的结果都是true，当然也包括它自身“isNaN(NaN)”，得出的结果同样是true。NaN产生的条件是：当参与<em>算术运算</em>的中的某个值不为数值型的值，那返回的结果就会为NaN。但“<em>+</em>”运算符比较特殊，因为有的时候它是可以作为<em>字符串拼接运算符</em>的。观察控制台中输出的结果：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-067.jpg">
        </code>
    </section>
    <!-- 章节练习 -->
    <!--<section class="unitPractice">
        <h3>&lt;章节练习一&gt;</h3>
        <p>
    </section>-->

</root>






