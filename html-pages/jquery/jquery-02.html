<root data-root="jQuery选择器">
	<!-- jQuery选择器概述 -->
	<section class="mt0">
    	<h3>jQuery选择器概述</h3>
    	<p>jQuery的选择器实现的根源当然还是DOM，但对选择器简化的灵感来源却是CSS，jQuery发展到现在这个版本，CSS3能做到的，jQuery基本上都能做到（:before、:after除外），如：元素选择器，ID选择器、class选择器、属性选择器、结构选择器、状态选择器，UI伪元素选择器等等。不仅如此，jQuery还提供了一些CSS办不到，JavaScript+DOM也不能一句话搞定的选择器。如：文本包含选择器、标签包含选择器、包含元素筛选选择器等。</p>
    	<p>由于jQuery“诞生”的日子比较早（2006年），它的很多做法受到了其它各类库的效仿，当然jQuery也从其它库的身上“要来”不少东西，如火热一时的<em title="该库目前已经在朝着Web应用框架方向转型了">MooTools</em>。jQuery的设计模式刚出来的时候就收到业界的高度重视，在它诞生的第二年，其内容就成为很多计算机高校必修或选修的课程，这种情况就现在看来都是不可思议的。</p>
    	<p>选择器作为jQuery的核心内容，更是被很多JS库所效仿。甚至可以很不负责任的说，就连原生的JavaScript和DOM都深受其影响，如getElementsByClassName这个ECMAScript 2010（简称ES5）才出现的选择器，以及紧跟着出现的querySelector()和querySelectorAll()这两个像极了jQuery的DOM选择器。</p>
    	<p><em>Sizzle</em>是jQuery的开发者John Resig新编写的一个JavaScript选择器，速度号称业界第一。它在2009年1月14日的时候导入了jQuery的核心，使得jQuery更加的强大。该作者根据ES5及一些外来的灵感在2012年8月9日的时候发布了重写的Sizzle，这使得jQuery的性能更加强大。当然，Sizzle一直也作为独立的版本存在着，如果不想使用jQuery，也可以单独下载Sizzle，它的体积比jQuery要小得多。</p>
    	<p>和DOM选择器一样，jQuery的选择器参数部分是以字符串的形式存在的，所以允许变量或字符串与变量拼接的形式。如：</p>
    	<p>
<code class="ideCode-js">var ele;
$("#" + ele).text("元素文本内容");

var div1 = "div";
$(div1).html("div文本内容");
</code>
   		</p>
   		<p>&lt;关于jQuery课程中“代码显示器”（JS部分）中的代码颜色说明&gt;</p>
		<ul class="indent">
			<li>“<em>关键字</em>”代码颜色用<i class="diamond" style="background-color:#ff3f77"></i>色进行表示</li>
			<li>“<em>变量名</em>”代码颜色用<i class="diamond" style="background-color:#ee6aff"></i>色进行表示</li>
			<li>“<em>方法名</em>”代码颜色用<i class="diamond" style="background-color:#51ebff"></i>色进行表示</li>
			<li>“<em>字符串</em>”代码颜色用<i class="diamond" style="background-color:#ece077"></i>色进行表示</li>
			<li>“<em>代码注释</em>”代码颜色用<i class="diamond" style="background-color:#00ff7f"></i>色进行表示</li>
			<li>“抽象词”或“特殊词”代码颜色用<i class="diamond" style="background-color:#b9ff00"></i>色进行表示（“抽象词”就是用于概括表示某一类代码的词，并非真正的功能性代码，实际使用中需替换为正确格式的代码单词或字符串，而“特殊词”指有一定特殊含义的词）</li>
		</ul>
    </section>
    <!-- 元素选择器 -->
	<section>
    	<h3>元素选择器</h3>
    	<p>基本语法：</p>
    	<p>
<code class="ideCode-js">$(TagName).method(function() {
	// 需要做的事
});</code>
   		</p>
   		<p>示例中的“TagName”指的是标签名，在实际使用中记得加上引号。如果有多个标签名，可以用英文逗号进行分割，如例：</p>
   		<p>
<code class="ideCode-js">$("div,p,span").css("color", "#3d3d3d");</code>
   		</p>
   		<p>上例的实现的效果是，同时将div、p和span三个标签的字体颜色设置为“#3d3d3d”。</p>
   		<p>jQuery的元素选择器（标签选择器）和DOM的选择器产生作用的区别在于，jQuery选择器不需要给元素加上索引下标即可选中页面中所有的标签，而DOM需要通过一次循环来实现所有元素标签的选择遍历。其实jQuery的选择器也会进行一次内部的循环遍历，只不过这样的操作不需要开发者来进行了而已。</p>
    </section>
    <!-- ID选择器 -->
    <section>
    	<h3>ID选择器</h3>
		<p>基本语法：</p>
    	<p>
<code class="ideCode-js">$("#" + ID).method(function() {
	// 需要做的事
});</code>
		</p>
   		<p>和标签选择器一样，如果要对多个ID进行操作需要用英文逗号进行分割，如例：</p>
   		<p>
<code class="ideCode-js">$("#userName, #userPwd").val("");</code>
   		</p>
   		<p>上例的实现的效果是，将ID为“userName”和“userPwd”的输入框（只有表单元素才能使用val()方法）的值置空。ID是唯一的，所以不会对选择器进行遍历，若页面中存在多个同名ID，则只会选择第一个。所以，ID选择器无论是在JavaScript中还是在jQuery中，都是最快的一种选择器。但需要提醒的是，前端开发其实是应该尽量避免过多的ID出现的，特别是那些只是用于布局或视觉样式操作的ID更是没有必要了。这样只会带来名称管理的负担，ID无论在什么时候都应该体现出其唯一性的特点。</p>
    </section>
    <!-- Class选择器 -->
    <section>
    	<h3>Class选择器</h3>
		<p>又称“<em>类选择器</em>”，基本语法：</p>
    	<p>
<code class="ideCode-js">$("." + ID).method(function() {
	// 需要做的事
});</code>
		</p>
   		<p>和元素选择器、ID选择器一样，Class选择器也能同时一次性选择多个Class。</p>
   		<p>
<code class="ideCode-js">$(".mainNav, .leftName, .footerNav").css("text-decoration", "none");</code>
		</p>
   		<p>并且该选择器和元素选择器一样会在jQuery核心代码的内部执行一次循环将所有同名的Class都进行选择。</p>
    </section>
    <section>
    	<h3>属性选择器</h3>
		<p>和CSS一样，jQuery也能通过元素的属性进行选择。基本语法：</p>
   		<p>
<code class="ideCode-js">$([AttributeName]).method(function() {
	// 需要做的事
});</code>
		</p>
   		<p>当然，CSS选择器能做到的jQuery自然也不会含糊，如：</p>
   		<p>
<code class="ideCode-js">$("div[data-info]");
$("div[data-info='roleInfo']");
$("input[type='radio']");
$("img[title^='简约风...']");
$("input[placeholder*='请输入']");
// 等等...</code>
		</p>
   		<p>也就是说，只要CSS能使用的属性选择器，jQuery也能使用。只需要将CSS的选择器直接复制过来就能使用，当然，不要忘了jQuery的所有选择器都需要用一对引号括起来，变量例外，不过得保证变量也是一个字符串。</p>
    </section>
    <!-- 子元素和后代选择器 -->
    <section>
    	<h3>子元素和后代选择器</h3>
		<p>基本语法：</p>
		<p>
<code class="ideCode-js">// 子元素选择器
$(selector &gt; selector).method();
// 后代元素选择器
$(selector selector).method();

// 子元素选择器实例
$("div > p > a").click(function() {
	// 要处理的事件2
});
// 后代元素选择器实例
$("form input[type='radio']").focus(function() {
	// 要处理的事件1
});</code>
		</p>
		<p>这和我们平时使用CSS选择器也是一样的，而jQuery提供的后代选择器方法和子元素选择器方法则有所不同，它可以处理更多的未知性，并且有一定的查询作用。jQuery查询子元素主要提供两个方法：</p>
		<dl class="attrExplain">
			<dt>子元素查询children()</dt>
			<dd>基本语法</dd>
			<dd>
<code class="ideCode-js">// 子元素查询
$(selector).children(param);

// 查找form标签下的div下的全部input表单元素，并添加获得焦点事件
$("form div").children("input").focus(function() {
	// 需要处理的事件
});

// 将div下面所有标签的字体大小设置为16像素
$("div").children().css("font-size", "16px");
</code>
			</dd>
			<dd>该方法的参数是一个可选项，当不给参数的时候，它能选择当前元素下的“直接子元素”，这相当于是CSS里的“parent &gt; child”，不同的是CSS必须给出“child”的选择器名，而jQuery则不用。这个区别产生的实际意义就是，CSS必须指定某个子元素，而不能选择全部子元素，而jQuery可以指定某个子元素，也可以选择全部子元素</dd>

			<dt>后代元素查询find()</dt>
			<dd>基本语法</dd>
			<dd>
<code class="ideCode-js">// 子元素查询
$(selector).find(param);

// 查找header内是在单独窗口打开超链接的a标签，并添加一个类名newWin
$("header").find("a[target='_blank']").addClass("newWin");

// 将ul内所有li（可能存在列表嵌套）找出并添加点击后弹出当前li文本的功能
$("ul").find("li").click(function(){
	var liText = $(this).text();
	alert(liText);
});
</code>
			</dd>
			<dd>和children方法一样该方法的参数是一个可选项，当不给参数的时候，它能选择当前元素下的所有子元素，这相当于是CSS里的“parent child”，至于区别也和children方法与CSS之间是一样的。</dd>
			<dd>但这里需要特别说明，由于find方法会将当前元素的所有子元素节点都进行一次遍历，也就说当前元素子元素节点数量过大的话，带来的性能损耗是相当大的，有的时候宁愿连续用两次children方法都不要用一次find方法，从代码节点控制的严谨性上来讲，children方法也是要优于find方法的。</dd>
		</dl>
    </section>
    <section>
    	<h3>同级选择器</h3>
		<p>虽然CSS官方的翻译是“同级、同胞选择器”，但是我们知道无论是CSS里的“+”还是“~”选择符都只能选择器当前节点之后的同级元素。</p>
   		<p>选择当前元素相邻的下一个同级元素的jQuery选择器写法为：</p>
   		<p>
<code class="ideCode-js">$("li + li").method(param);</code>
		</p>
   		<p>而选择当前元素之后所有的同级元素的jQuery选择器写法为：</p>
   		<p>
<code class="ideCode-js">$("li ~ li").method(param);</code>
		</p>
   		<p>这和我们使用CSS的选择符进行元素的选择没有任何区别。但实际上，这两个选择符在jQuery里面是很少出现的，因为jQuery有更好的选择器同级元素的方法，而且性能表现上由于会省略掉正则判断一环，所以是一种更佳的选择器。</p>
   		<p>接下来我们就来介绍jQuery里的这些同级元素选择器。</p>
   		<dl class="attrExplain">
   			<dt>上一个同级元素prev()</dt>
   			<dd>基本语法：</dd>
   			<dd>
<code class="ideCode-js">$(selector).prev();</code>
   			</dd>
   			<dd>该方法不需要参数，因为这个方法能选到的元素节点是唯一的。如果找不到上一个元素节点，则会返回一个length为0的jQuery对象。没有办法使用现有的CSS选择器来实现该功能。</dd>

			<dt>下一个同级元素next()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).next();</code>
			</dd>
			<dd>该方法和prev()相比，只是选择的是当前元素的下一个元素节点，其它特性基本一致。</dd>

			<dt>之前的同级元素prevAll()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).prevAll(param);</code>
			</dd>
			<dd>该方法的参数为一个字符串，设置内容为CSS选择器，可选填。当参数为空的时候表示的当前元素之前所有的统计元素，当设置参数的时候必须是一个字符串或存有字符串的变量（可以使用变量+字符串的拼接操作），和jQuery选择器一样使用CSS选择器作为参数内容，这样就会返回当前元素之前指定选择器的节点。</dd>
			<dd>我们通过一个示例来理解该方法的功能，现有如下HTML代码：</dd>
			<dd>
<code class="ideCode-html">&lt;ul class="skill-list"&gt;
	&lt;li class="html"&gt;HTML&lt;/li&gt;
	&lt;li class="css"&gt;CSS&lt;/li&gt;
	&lt;li class="js"&gt;JavaScript&lt;/li&gt;
	&lt;li class="jq"&gt;jQuery&lt;/li&gt;
	&lt;li class="ng"&gt;Angular&lt;/li&gt;
	&lt;li class="rc"&gt;React&lt;/li&gt;
	&lt;li class="v"&gt;Vue&lt;/li&gt;
&lt;/ul&gt;</code>
			</dd>
			<dd>jQuery代码如下：</dd>
			<dd>
<code class="ideCode-js">// 点击列表项后使之前的列表项编程橙色
$(".skill-list > li").click(function() {
	$(this).prevAll().css("color", "#f80");
});</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-003.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-003.html" ></iframe>
			</dd>
			<dd>效果还是比较直观的，点击列表项的时候，当前项没有效果，当前项之前的列表项都会生效。现在我们为prevAll方法加上一个".css"选择器作为参数，这样无论点击class为“css”之后的哪一项，拥有“css”的项都会生效颜色变化代码。</dd>
			<dd>
<code class="ideCode-js">// 点击CSS之后的列表项，CSS项都会变成蓝色，而点击CSS或之前的项则不会有任何效果
$(".skill-list > li").click(function() {
	// prevAll方法内只能传入一个CSS选择器
	$(this).prevAll(".css").css("color", "#00f");
});</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-004.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-004.html" ></iframe>
			</dd>
			<dd>如果当前元素之前没有元素节点，则会返回一个length为0的jQuery对象。另外，还需要注意的一个小细节就是这类方法（后面出现的nextAll、prevUntil、nextUntil也是一样的）的匹配结果的顺序是从当前标签开始的一个“由近到远”的jQuery对象数组。例如，点击上例中的“jQuery”列表项并使用prevAll不带参数的遍历，出来的结果是“JavaScript → CSS → HTML”这样的顺序，了解这点，对我们以后实现一些复杂需求有思维上的帮助。</dd>

			<dt>之后的同级元素nextAll()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).nextAll(param);</code>
			</dd>
			<dd>方法和prevAll()相比，只是选择的是当前元素之后的元素节点，其它特性基本一致。</dd>

			<dt>之前的第一个同级匹配元素prevUntil()</dt>
			<dd>该方法用于匹配当前元素之前一直到满足匹配条件之间（不包括这个元素）的同级元素，基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).prevUntil(param);</code>
			</dd>
			<dd>该方法的参数虽然是可选项，但总是建议传入参数，否则它和不带参数的prevAll方法几乎没有区别，也达不到我们使用它的目的。我们用这个方法来实现一个如下一个功能。</dd>
			<dd>HTML代码示例：</dd>
			<dd>
<code class="ideCode-html">&lt;main&gt;
	&lt;h3&gt;水果类&lt;/h3&gt;
	&lt;p&gt;苹果&lt;/p&gt;
	&lt;p&gt;梨子&lt;/p&gt;
	&lt;p&gt;香蕉&lt;/p&gt;
	&lt;p class="describe"&gt;补充维生素ABCDEFG&lt;/p&gt;
	&lt;h3&gt;零食类&lt;/h3&gt;
	&lt;p&gt;辣条&lt;/p&gt;
	&lt;p&gt;薯片&lt;/p&gt;
	&lt;p&gt;饼干&lt;/p&gt;
	&lt;p class="describe"&gt;杀死维生素ABCDEFG&lt;/p&gt;
	&lt;h3&gt;肉类&lt;/h3&gt;
	&lt;p&gt;牛肉&lt;/p&gt;
	&lt;p&gt;猪肉&lt;/p&gt;
	&lt;p&gt;羊肉&lt;/p&gt;
	&lt;p class="describe"&gt;补充蛋白质、能量、纤维素&lt;/p&gt;
&lt;/main&gt;</code>
			</dd>
			<dd>jQuery代码示例：</dd>
			<dd>
<code class="ideCode-js">// 点击当前p元素之后，一直到h3为止的元素都变成紫色
$("p").click(function() {
	$(this).prevUntil("h3").css("color","#f0f");
});
</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-005.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-005.html" ></iframe>
			</dd>
			<dt>后前的第一个同级匹配元素nextUntil()</dt>
			<dd>该方法用于匹配当前元素之后一直到满足匹配条件之间（不包括这个元素）的同级元素，基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).nextUntil(param);</code>
			</dd>
			<dd>该方法和prevUntil特性完全一样，只是匹配的元素是从当前元素开始之后的元素而已。</dd>
			<dt>同级兄弟节点siblings()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).siblings(param);</code>
			</dd>
			<dd>该方法的参数也是可选的，当不配置参数的时候该方法会匹配到除当前选择器节点以外的其它节点，而配置参数之后，那它就会去配置参数内配置的选择器节点。该方法在很多场合下都非常好用，如制作一个拥有被点选效果的按钮组或导航。</dd>
			<dd>HTML代码示例：</dd>
			<dd>
<code class="ideCode-html">&lt;nav&gt;
	&lt;!-- 默认让列表中第一项“选中”（其实只是一个CSS样式而已）--&gt;
	&lt;ul class="mainNav"&gt;
		&lt;li class="checked"&gt;英雄联盟&lt;/li&gt;
		&lt;li&gt;王者荣耀&lt;/li&gt;
		&lt;li&gt;穿越火线&lt;/li&gt;
		&lt;li&gt;地下城与勇士&lt;/li&gt;
		&lt;li&gt;魔兽世界&lt;/li&gt;
		&lt;li&gt;梦幻西游&lt;/li&gt;
		&lt;li&gt;炉石传说&lt;/li&gt;
	&lt;/ul&gt;
&lt;/nav&gt;</code>
			</dd>
			<dd>jQuery代码示例：</dd>
			<dd>
<code class="ideCode-js">// 当行点击选中效果
$("nav > ul.mainNav > li").click(function() {
	// 当前元素添加指定class，其它所有兄弟元素则移除这个class
	// “checked”这个class是我们在CSS里预先设置好样式的
	$(this).addClass("checked").siblings().removeClass("checked");
});
</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-006.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-006.html" ></iframe>
			</dd>
			<dd>这样一个功能，若要用原生的JavaScript去进行还原，单是第一个选择器部分“$("nav > ul.mainNav > li")”就得耗费不少代码，还得考虑用一个循环给这些节点绑定事件。进入到添加/移除选中效果的时候还得用一个循环或者节点精确查找的方式去移除上一次被选中选中的class。各种循环判断下来，初步估计5行或以上的代码是少不了的，而且由于JS语法属性名称关系，每行的字节量还不会少。然而，这样一个需要涉及多处小逻辑的功能，用jQuery竟然两行有效代码就搞定了，这里面“siblings()”方法“功不可没”。</dd>
			<dd>请在自己的编辑器里进行实践以加深对本节方法的理解，并务必花时间思考这些方法在实际运用中可以帮助我们完成那些工作。</dd>
    	</dl>
    </section>
    <!-- 父级选择器 -->
    <section>
    	<h3>父级选择器</h3>
		<p></p>
    </section>
    <!-- 章节练习 -->
	<section class="unitPractice">
		<h3>&lt;章节练习一&gt;</h3>
		<p>根据本章之前所学的知识点，完成一个“手风琴菜单”功能，需求细节如下：</p>
		<p>&lt;HTML代码结构&gt;（为节约时间直接复制该段代码即可）</p>
<pre>&lt;div class="leftNavMenu"&gt;
	&lt;ul&gt;
		&lt;li class="checked"&gt;
			&lt;a&gt;域名管理&lt;/a&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;添加域名&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;启动CDN&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;修改所属项目&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;访问控制&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;高级配置&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;
			&lt;a&gt;缓存刷新&lt;/a&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;URL刷新&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;目录刷新&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;操作记录&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;
			&lt;a&gt;统计分析&lt;/a&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;使用量统计&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;访问情况统计&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;状态码统计&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;源站统计&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;全网状态监控&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;运营月报&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;
			&lt;a&gt;高级工具&lt;/a&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;证书管理&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;流量包管理&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;
			&lt;a&gt;诊断工具&lt;/a&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;节点IP归属查询&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;自动故障诊断&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
&lt;/div&gt;
</pre>
		<p>可以<a href="html-pages/jquery/codeEffect/code-007.css" download="selector-01">点击此处</a>下载该示例所需CSS文件，也可以根据自己的能力选择去写属于自己的CSS样式或对下载的CSS文件进行修改。</p>
		<p>主要完成的功能就是：当鼠标点击任意一项的时候，当前列表项“展开”，其它列表项则“收拢”。</p>
		<p>&lt;最终效果大致如图所示&gt;</p>
		<p>
			<img src="img/content/jquery/accordion-menu.gif" title="代码效果示例图" style="border:1px solid #eee;">
		</p>
	</section>
    <!-- 奇偶选择器 -->
    <section>
    	<h3>奇偶选择器</h3>
		<p></p>
    </section>
    <!-- 结构性伪类选择器 -->
    <section>
    	<h3>结构性伪类选择器</h3>
		<p></p>
    </section>
    <!-- 状态选择器 -->
    <section>
    	<h3>状态选择器</h3>
		<p></p>
    </section>
    <!-- 表单元素选择器 -->
    <section>
    	<h3>表单元素选择器</h3>
		<p></p>
    </section>
    <!-- 索引选择器 -->
    <section>
    	<h3>索引选择器</h3>
		<p></p>
    </section>
    <!-- 动画元素选择器 -->
    <section>
    	<h3>动画元素选择器</h3>
		<p></p>
    </section>
    <!-- 哈希目标选择器 -->
    <section>
    	<h3>哈希目标选择器</h3>
		<p></p>
    </section>
    <!-- 文本包含选择器 -->
    <section>
    	<h3>文本包含选择器</h3>
		<p></p>
    </section>
    <!-- 标签包含选择器 -->
    <section>
    	<h3>标签包含选择器</h3>
		<p></p>
    </section>
    <!-- 包含元素筛选选择器 -->
    <section>
    	<h3>包含元素筛选选择器</h3>
		<p></p>
    </section>
    <!-- 空内容选择器 -->
    <section>
    	<h3>空内容选择器</h3>
		<p></p>
    </section>
</root>



