<root data-root="jQuery选择器">
	<!-- jQuery选择器概述 -->
	<section class="mt0">
    	<h3>jQuery选择器概述</h3>
    	<p>jQuery的选择器实现的根源当然还是DOM，但对选择器简化的灵感来源却是CSS，jQuery发展到现在这个版本，CSS3能做到的，jQuery基本上都能做到（:before、:after除外），如：元素选择器，ID选择器、class选择器、属性选择器、结构选择器、状态选择器，UI伪元素选择器等等。不仅如此，jQuery还提供了一些CSS办不到，JavaScript+DOM也不能一句话搞定的选择器。如：文本包含选择器、标签包含选择器、包含元素筛选选择器等。</p>
    	<p>由于jQuery“诞生”的日子比较早（2006年），它的很多做法受到了其它各类库的效仿，当然jQuery也从其它库的身上“要来”不少东西，如火热一时的<em title="该库目前已经在朝着Web应用框架方向转型了">MooTools</em>。jQuery的设计模式刚出来的时候就收到业界的高度重视，在它诞生的第二年，其内容就成为很多计算机高校必修或选修的课程，这种情况就现在看来都是不可思议的。</p>
    	<p>选择器作为jQuery的核心内容，更是被很多JS库所效仿。甚至可以很不负责任的说，就连原生的JavaScript和DOM都深受其影响，如getElementsByClassName这个ECMAScript 2010（简称ES5）才出现的选择器，以及紧跟着出现的querySelector()和querySelectorAll()这两个像极了jQuery的DOM选择器。</p>
    	<p><em>Sizzle</em>是jQuery的开发者John Resig新编写的一个JavaScript选择器，速度号称业界第一。它在2009年1月14日的时候导入了jQuery的核心，使得jQuery更加的强大。该作者根据ES5及一些外来的灵感在2012年8月9日的时候发布了重写的Sizzle，这使得jQuery的性能更加强大。当然，Sizzle一直也作为独立的版本存在着，如果不想使用jQuery，也可以单独下载Sizzle，它的体积比jQuery要小得多。</p>
    	<p>和DOM选择器一样，jQuery的选择器参数部分是以字符串的形式存在的，所以允许变量或字符串与变量拼接的形式。如：</p>
    	<p>
<code class="ideCode-js">// 置空所有的文本框的值
$("input").val("");

// 将用户名输入框的值设置为“aulence”
var getName = "aulence";
$("#userName").val(getName);

// 将id为“userInfo”元素的文本内容设置为“用户信息”
var ele = "userInfo";
$("#" + ele).text("用户信息");

// 将class为“showParg”的元素的HTML内容替换为一个“&lt;p&gt;段落文本内容&lt;/p&gt;”的p标签
var parag = ".showParg";
$(parag).html("&lt;p&gt;段落文本内容&lt;/p&gt;");</code>
   		</p>
   		<p>关于jQuery课程中“代码显示器”（JS部分）中的代码颜色的一些约定规则：</p>
		<ul class="indent">
			<li>“<em>关键字</em>”代码颜色用<i class="diamond" style="background-color:#ff3f77"></i>色进行表示</li>
			<li>“<em>内置对象</em>”（包括BOM/DOM/函数）代码颜色用<i class="diamond" style="background-color:#ff6d6d"></i>色进行表示</li>
			<li>“<em>变量名</em>”代码颜色用<i class="diamond" style="background-color:#ee6aff"></i>色进行表示</li>
			<li>“<em>方法名</em>”代码颜色用<i class="diamond" style="background-color:#51ebff"></i>色进行表示</li>
			<li>“<em>对象属性名（键名）</em>”代码颜色用<i class="diamond" style="background-color:#6c9fff"></i>色进行表示</li>
			<li>“<em>字符串</em>”代码颜色用<i class="diamond" style="background-color:#ece077"></i>色进行表示</li>
			<li>“<em>代码注释</em>”代码颜色用<i class="diamond" style="background-color:#00ff7f"></i>色进行表示</li>
			<li>“抽象词”或“特殊词”代码颜色用<i class="diamond" style="background-color:#b9ff00"></i>色进行表示（“抽象词”就是用于概括表示某一类代码的词，并非真正的功能性代码，实际使用中需替换为正确格式的代码单词或字符串，而“特殊词”指有一定特殊含义的词）</li>
		</ul>
		<p>当然，这些规定不需要去记忆。只是当无法区分某段代码中的某个代码单词的作用时可以方便在这里查询。</p>
    </section>
    <!-- 元素选择器 -->
	<section>
    	<h3>元素选择器</h3>
    	<p>基本语法：</p>
    	<p>
<code class="ideCode-js">$(TagName).method(function() {
	// 需要做的事
});</code>
   		</p>
   		<p>示例中的“TagName”指的是标签名，在实际使用中记得加上引号。如果有多个标签名，可以用英文逗号进行分割，如例：</p>
   		<p>
<code class="ideCode-js">$("div,p,span").css("color", "#3d3d3d");</code>
   		</p>
   		<p>上例的实现的效果是，同时将div、p和span三个标签的字体颜色设置为“#3d3d3d”。</p>
   		<p>jQuery的元素选择器（标签选择器）和DOM的选择器产生作用的区别在于，jQuery选择器不需要给元素加上索引下标即可选中页面中所有的标签，而DOM需要通过一次循环来实现所有元素标签的选择遍历。其实jQuery的选择器也会进行一次内部的循环遍历，只不过这样的操作不需要开发者来进行了而已。</p>
    </section>
    <!-- ID选择器 -->
    <section>
    	<h3>ID选择器</h3>
		<p>基本语法：</p>
    	<p>
<code class="ideCode-js">$("#" + ID).method(function() {
	// 需要做的事
});</code>
		</p>
   		<p>和标签选择器一样，如果要对多个ID进行操作需要用英文逗号进行分割，如例：</p>
   		<p>
<code class="ideCode-js">$("#userName, #userPwd").val("");</code>
   		</p>
   		<p>上例的实现的效果是，将ID为“userName”和“userPwd”的输入框（只有表单元素才能使用val()方法）的值置空。ID是唯一的，所以不会对选择器进行遍历，若页面中存在多个同名ID，则只会选择第一个。所以，ID选择器无论是在JavaScript中还是在jQuery中，都是最快的一种选择器。但需要提醒的是，前端开发其实是应该尽量避免过多的ID出现的，特别是那些只是用于布局或视觉样式操作的ID更是没有必要了。这样只会带来名称管理的负担，ID无论在什么时候都应该体现出其唯一性的特点。</p>
    </section>
    <!-- Class选择器 -->
    <section>
    	<h3>Class选择器</h3>
		<p>又称“<em>类选择器</em>”，基本语法：</p>
    	<p>
<code class="ideCode-js">$("." + ID).method(function() {
	// 需要做的事
});</code>
		</p>
   		<p>和元素选择器、ID选择器一样，Class选择器也能同时一次性选择多个Class。</p>
   		<p>
<code class="ideCode-js">$(".mainNav, .leftName, .footerNav").css("text-decoration", "none");</code>
		</p>
   		<p>并且该选择器和元素选择器一样会在jQuery核心代码的内部执行一次循环将所有同名的Class都进行选择。</p>
    </section>
    <section>
    	<h3>属性选择器</h3>
		<p>和CSS一样，jQuery也能通过元素的属性进行选择。基本语法：</p>
   		<p>
<code class="ideCode-js">$([AttributeName]).method(function() {
	// 需要做的事
});</code>
		</p>
   		<p>当然，CSS选择器能做到的jQuery自然也不会含糊，如：</p>
   		<p>
<code class="ideCode-js">$("div[data-info]");
$("div[data-info='roleInfo']");
$("input[type='radio']");
$("img[title^='简约风...']");
$("input[placeholder*='请输入']");
// 等等...</code>
		</p>
   		<p>也就是说，只要CSS能使用的属性选择器，jQuery也能使用。只需要将CSS的选择器直接复制过来就能使用，当然，不要忘了jQuery的所有选择器都需要用一对引号括起来，变量例外，不过得保证变量也是一个字符串。</p>
    </section>
    <!-- 子元素和后代选择器 -->
    <section>
    	<h3>子元素和后代选择器</h3>
		<p>基本语法：</p>
		<p>
<code class="ideCode-js">// 子元素选择器
$(selector &gt; selector).method();
// 后代元素选择器
$(selector selector).method();

// 子元素选择器实例
$("div > p > a").click(function() {
	// 要处理的事件1
});
// 后代元素选择器实例
$("form input[type='radio']").focus(function() {
	// 要处理的事件2"
});</code>
		</p>
		<p>这和我们平时使用CSS选择器也是一样的，而jQuery提供的后代选择器方法和子元素选择器方法则有所不同，它可以处理更多的未知性，并且有一定的查询作用。jQuery查询子元素主要提供两个方法：</p>
		<dl class="attrExplain">
			<dt>子元素查询children()</dt>
			<dd>基本语法</dd>
			<dd>
<code class="ideCode-js">// 子元素查询
$(selector).children(param);

// 查找form标签下的div下的全部input表单元素，并添加获得焦点事件
$("form div").children("input").focus(function() {
	// 需要处理的事件
});

// 将div下面所有标签的字体大小设置为16像素
$("div").children().css("font-size", "16px");
</code>
			</dd>
			<dd>该方法的参数是一个可选项，当不给参数的时候，它能选择当前元素下的“直接子元素”，这相当于是CSS里的“parent &gt; child”，不同的是CSS必须给出“child”的选择器名，而jQuery则不用。这个区别产生的实际意义就是，CSS必须指定某个子元素，而不能选择全部子元素，而jQuery可以指定某个子元素，也可以选择全部子元素</dd>

			<dt>后代元素查询find()</dt>
			<dd>基本语法</dd>
			<dd>
<code class="ideCode-js">// 子元素查询
$(selector).find(param);

// 查找header内是在单独窗口打开超链接的a标签，并添加一个类名newWin
$("header").find("a[target='_blank']").addClass("newWin");

// 将ul内所有li（可能存在列表嵌套）找出并添加点击后弹出当前li文本的功能
$("ul").find("li").click(function(){
	var liText = $(this).text();
	alert(liText);
});
</code>
			</dd>
			<dd>和children方法一样该方法的参数是一个可选项，当不给参数的时候，它能选择当前元素下的所有子元素，这相当于是CSS里的“parent child”，至于区别也和children方法与CSS之间是一样的。</dd>
			<dd>但这里需要特别说明，由于find方法会将当前元素的所有子元素节点都进行一次遍历，也就说当前元素子元素节点数量过大的话，带来的性能损耗是相当大的，有的时候宁愿连续用两次children方法都不要用一次find方法，从代码节点控制的严谨性上来讲，children方法也是要优于find方法的。</dd>
		</dl>
    </section>
    <section>
    	<h3>同级选择器</h3>
		<p>虽然CSS官方的翻译是“同级、同胞选择器”，但是我们知道无论是CSS里的“+”还是“~”选择符都只能选择器当前节点之后的同级元素。</p>
   		<p>选择当前元素相邻的下一个同级元素的jQuery选择器写法为：</p>
   		<p>
<code class="ideCode-js">$("li + li").method(param);</code>
		</p>
   		<p>而选择当前元素之后所有的同级元素的jQuery选择器写法为：</p>
   		<p>
<code class="ideCode-js">$("li ~ li").method(param);</code>
		</p>
   		<p>这和我们使用CSS的选择符进行元素的选择没有任何区别。但实际上，这两个选择符在jQuery里面是很少出现的，因为jQuery有更好的选择器同级元素的方法，而且性能表现上由于会省略掉正则判断一环，所以是一种更佳的选择器。</p>
   		<p>接下来我们就来介绍jQuery里的这些同级元素选择器。</p>
   		<dl class="attrExplain">
   			<dt>上一个同级元素prev()</dt>
   			<dd>基本语法：</dd>
   			<dd>
<code class="ideCode-js">$(selector).prev();</code>
   			</dd>
   			<dd>该方法不需要参数，因为这个方法能选到的元素节点是唯一的。如果找不到上一个元素节点，则会返回一个length为0的jQuery对象。没有办法使用现有的CSS选择器来实现该功能。</dd>

			<dt>下一个同级元素next()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).next();</code>
			</dd>
			<dd>该方法和prev()相比，只是选择的是当前元素的下一个元素节点，其它特性基本一致。</dd>

			<dt>之前的同级元素prevAll()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).prevAll(param);</code>
			</dd>
			<dd>该方法的参数为一个字符串，设置内容为CSS选择器，可选填。当参数为空的时候表示的当前元素之前所有的统计元素，当设置参数的时候必须是一个字符串或存有字符串的变量（可以使用变量+字符串的拼接操作），和jQuery选择器一样使用CSS选择器作为参数内容，这样就会返回当前元素之前指定选择器的节点。</dd>
			<dd>我们通过一个示例来理解该方法的功能，现有如下HTML代码：</dd>
			<dd>
<code class="ideCode-html">&lt;ul class="skill-list"&gt;
	&lt;li class="html"&gt;HTML&lt;/li&gt;
	&lt;li class="css"&gt;CSS&lt;/li&gt;
	&lt;li class="js"&gt;JavaScript&lt;/li&gt;
	&lt;li class="jq"&gt;jQuery&lt;/li&gt;
	&lt;li class="ng"&gt;Angular&lt;/li&gt;
	&lt;li class="rc"&gt;React&lt;/li&gt;
	&lt;li class="v"&gt;Vue&lt;/li&gt;
&lt;/ul&gt;</code>
			</dd>
			<dd>jQuery代码如下：</dd>
			<dd>
<code class="ideCode-js">// 点击列表项后使之前的列表项编程橙色
$(".skill-list > li").click(function() {
	$(this).prevAll().css("color", "#f80");
});</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-003.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-003.html" ></iframe>
			</dd>
			<dd>效果还是比较直观的，点击列表项的时候，当前项没有效果，当前项之前的列表项都会生效。现在我们为prevAll方法加上一个".css"选择器作为参数，这样无论点击class为“css”之后的哪一项，拥有“css”的项都会生效颜色变化代码。</dd>
			<dd>
<code class="ideCode-js">// 点击CSS之后的列表项，CSS项都会变成蓝色，而点击CSS或之前的项则不会有任何效果
$(".skill-list > li").click(function() {
	// prevAll方法内只能传入一个CSS选择器
	$(this).prevAll(".css").css("color", "#00f");
});</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-004.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-004.html" ></iframe>
			</dd>
			<dd>如果当前元素之前没有元素节点，则会返回一个length为0的jQuery对象。另外，还需要注意的一个小细节就是这类方法（后面出现的nextAll、prevUntil、nextUntil也是一样的）的匹配结果的顺序是从当前标签开始的一个“由近到远”的jQuery对象数组。例如，点击上例中的“jQuery”列表项并使用prevAll不带参数的遍历，出来的结果是“JavaScript → CSS → HTML”这样的顺序，了解这点，对我们以后实现一些复杂需求有思维上的帮助。</dd>

			<dt>之后的同级元素nextAll()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).nextAll(param);</code>
			</dd>
			<dd>方法和prevAll()相比，只是选择的是当前元素之后的元素节点，其它特性基本一致。</dd>

			<dt>之前的第一个同级匹配元素prevUntil()</dt>
			<dd>该方法用于匹配当前元素之前一直到满足匹配条件之间（不包括这个元素）的同级元素，基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).prevUntil(param);</code>
			</dd>
			<dd>该方法的参数虽然是可选项，但总是建议传入参数，否则它和不带参数的prevAll方法几乎没有区别，也达不到我们使用它的目的。我们用这个方法来实现一个如下一个功能。</dd>
			<dd>HTML代码示例：</dd>
			<dd>
<code class="ideCode-html">&lt;main&gt;
	&lt;h3&gt;水果类&lt;/h3&gt;
	&lt;p&gt;苹果&lt;/p&gt;
	&lt;p&gt;梨子&lt;/p&gt;
	&lt;p&gt;香蕉&lt;/p&gt;
	&lt;p class="describe"&gt;补充维生素ABCDEFG&lt;/p&gt;
	&lt;h3&gt;零食类&lt;/h3&gt;
	&lt;p&gt;辣条&lt;/p&gt;
	&lt;p&gt;薯片&lt;/p&gt;
	&lt;p&gt;饼干&lt;/p&gt;
	&lt;p class="describe"&gt;杀死维生素ABCDEFG&lt;/p&gt;
	&lt;h3&gt;肉类&lt;/h3&gt;
	&lt;p&gt;牛肉&lt;/p&gt;
	&lt;p&gt;猪肉&lt;/p&gt;
	&lt;p&gt;羊肉&lt;/p&gt;
	&lt;p class="describe"&gt;补充蛋白质、能量、纤维素&lt;/p&gt;
&lt;/main&gt;</code>
			</dd>
			<dd>jQuery代码示例：</dd>
			<dd>
<code class="ideCode-js">// 点击当前p元素之后，一直到h3为止的元素都变成紫色
$("p").click(function() {
	$(this).prevUntil("h3").css("color","#f0f");
});
</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-005.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-005.html" ></iframe>
			</dd>
			<dt>后前的第一个同级匹配元素nextUntil()</dt>
			<dd>该方法用于匹配当前元素之后一直到满足匹配条件之间（不包括这个元素）的同级元素，基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).nextUntil(param);</code>
			</dd>
			<dd>该方法和prevUntil特性完全一样，只是匹配的元素是从当前元素开始之后的元素而已。</dd>
			<dt>同级兄弟节点siblings()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).siblings(param);</code>
			</dd>
			<dd>该方法的参数也是可选的，当不配置参数的时候该方法会匹配到除当前选择器节点以外的其它节点，而配置参数之后，那它就会去配置参数内配置的选择器节点。该方法在很多场合下都非常好用，如制作一个拥有被点选效果的按钮组或导航。</dd>
			<dd>HTML代码示例：</dd>
			<dd>
<code class="ideCode-html">&lt;nav&gt;
	&lt;!-- 默认让列表中第一项“选中”（其实只是一个CSS样式而已）--&gt;
	&lt;ul class="mainNav"&gt;
		&lt;li class="checked"&gt;英雄联盟&lt;/li&gt;
		&lt;li&gt;王者荣耀&lt;/li&gt;
		&lt;li&gt;穿越火线&lt;/li&gt;
		&lt;li&gt;地下城与勇士&lt;/li&gt;
		&lt;li&gt;魔兽世界&lt;/li&gt;
		&lt;li&gt;梦幻西游&lt;/li&gt;
		&lt;li&gt;炉石传说&lt;/li&gt;
	&lt;/ul&gt;
&lt;/nav&gt;</code>
			</dd>
			<dd>jQuery代码示例：</dd>
			<dd>
<code class="ideCode-js">// 当行点击选中效果
$("nav > ul.mainNav > li").click(function() {
	// 当前元素添加指定class，其它所有兄弟元素则移除这个class
	// “checked”这个class是我们在CSS里预先设置好样式的
	$(this).addClass("checked").siblings().removeClass("checked");
});
</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-006.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-006.html" ></iframe>
			</dd>
			<dd>这样一个功能，若要用原生的JavaScript去进行还原，单是第一个选择器部分“$("nav > ul.mainNav > li")”就得耗费不少代码，还得考虑用一个循环给这些节点绑定事件。进入到添加/移除选中效果的时候还得用一个循环或者节点精确查找的方式去移除上一次被选中选中的class。各种循环判断下来，初步估计5行或以上的代码是少不了的，而且由于JS语法属性名称关系，每行的字节量还不会少。然而，这样一个需要涉及多处小逻辑的功能，用jQuery竟然两行有效代码就搞定了，这里面“siblings()”方法“功不可没”。</dd>
			<dd>请在自己的编辑器里进行实践以加深对本节方法的理解，并务必花时间思考这些方法在实际运用中可以帮助我们完成那些工作。</dd>
    	</dl>
    </section>
    <!-- 父级选择器 -->
    <section>
    	<h3>父级选择器</h3>
		<p>在CSS中没有可以选择父级的选择器，所以jQuery也没有办法像之前的选择器那样提供可以查询父级的CSS选择器，但是jQuery提供了三个方法来查询选择父级（祖先级）元素，这三个方法配合之前所学选择器方法基本可以应付各种节点选择的情况了。</p>
		<dl class="attrExplain">
			<dt>选择直接父级parent()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).parent();</code>
			</dd>
			<dd>该方法不需要加上参数，因为每个节点的父级是唯一的。若加上了一个选择器字符串作为参数，如果参数指的就是父级那和不加参数没有任何区别，若参数指的不是当前节点的父级，那返回的是一个length为0的jQuery对象。虽然说可以利用这一点来判断一个元素的父级是否是某个元素，但并不推荐这样用。一般我们都是用<em>is()</em>方法来判断当前元素是否是我们制定的某个元素，这在我们本章中会进行讲解。</dd>

			<dt>选择全部或指定父级集合parents()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).parents(param);</code>
			</dd>
			<dd>该方法除了有一个可选参数（通常都会设置该参数），和直接父元素选择器parent相比，这个方法只是多了一个字母“s”，由此可见，该方法返回的是一个集合。当然，这个集合和我们对JS中数组的理解还是有些差别的，因为如果使用jQuery方法来操作这个集合也是不需要进行循环的。我们还是通过一个例子来进行说明：</dd>
			<dd>HTML代码示例：</dd>
			<dd>
<code class="ideCode-html">&lt;body&gt;
	&lt;main class="a"&gt;
		&lt;article class="a b"&gt;
			&lt;h1&gt;文章的标题&lt;/h1&gt;
			&lt;section class="a b c"&gt;
				&lt;h2&gt;二级标题&lt;/h2&gt;
				&lt;p&gt;正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容...&lt;/p&gt;
				&lt;p&gt;正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容...&lt;/p&gt;
			&lt;/section&gt;
			&lt;section class="a b c"&gt;
				&lt;h2&gt;二级标题&lt;/h2&gt;
				&lt;p&gt;正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容...&lt;/p&gt;
				&lt;p&gt;正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容...&lt;/p&gt;
			&lt;/section&gt;
		&lt;/article&gt;
	&lt;/main&gt;
&lt;/body&gt;</code>
			</dd>
			<dd>jQuery代码示例：</dd>
			<dd>
<code class="ideCode-js">// 点击段落为所有的父级添加红色边框
$("p").click(function() {
	$(this).parents().css("border","1px solid #f00");
	// 观察点击事件后控制台中输出的结果
	console.log($(this).parents());
});</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-008.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-008.html"></iframe>
			</dd>
			<dd>通过示例可以发现（在浏览器开发者工具中的“Elements”中观察结构详情），当段落标签被点击之后，只要是p标签父级的元素都加上的红色的边框，而且在控制台中输出了这个父级的集合。</dd>
			<dd>在开发者工具中可以清晰地看到HTML（document）的层次结构：</dd>
			<dd><img src="img/content/jquery/parents-list.jpg" title="Google Chrome控制台Elements" style="border:1px solid #eee;"></dd>
			<dd>再来看一个例子：</dd>
			<dd>
<code class="ideCode-js">// 点击段落让main的宽度设为760像素，背景色变为墨绿色，且水平居中
$("p").click(function() {
	$(this).parents("main.a").css({
		width: "760px",
		backgroundColor: "#08957f",
		margin: "0 auto"
	});
	// 观察点击事件后控制台中输出的结果
	console.log($(this).parents("main.a"));
});</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-009.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-009.html"></iframe>
			</dd>
			<dd>这回输出的结果只有一个，因为满足parents方法内参数选择器既是main标签，而且Class又是“a”的，从当前的结构上来讲只有唯一的一个。由此，可以自行完成一个小测试，将class为“b”的元素设置为1像素实线的红色边框，并在控制台中将这个parents的集合输出来看看。（由于保证示例显示效果，代码中已经设置过每个元素的padding值，这里自行设置即可）</dd>

			<dt>选择指定父级closest()</dt>
			<dd>基本语法</dd>
			<dd>
<code class="ideCode-js">$(selector).closest(param);</code>
			</dd>
			<dd>该方法同样是选择父级，但参数是一个<em>必填项</em>，否则将返回一个length为0的空jQuery对象，也无法实现我们预期的功能了。closest方法选择父级有2个特点：</dd>
			<ul>
				<li>所需查询的父级不一定是当前元素节点的直接父级</li>
				<li>查询顺序是从当前节点开始，遇到的第一个符合条件的父级，也就是说结果是唯一的</li>
			</ul>
			<dd>还是通过一个示例来了解closest()方法，HTML如下：</dd>
			<dd>
<code class="ideCode-html">&lt;div class="t-1 a"&gt;
	&lt;div&gt;t-1&lt;/div&gt;
	&lt;div class="t-2 a"&gt;
		&lt;div&gt;t-2&lt;/div&gt;
		&lt;div class="t-3 b"&gt;
			&lt;div&gt;t-3&lt;/div&gt;
			&lt;div class="t-4 b"&gt;
				&lt;div&gt;t-4&lt;/div&gt;
				&lt;div class="t-5"&gt;
					&lt;div&gt;t-5&lt;/div&gt;
					&lt;button class="btn" type="button"&gt;按钮&lt;/button&gt;
				&lt;/div&gt;
			&lt;/div&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/div&gt;</code>
			</dd>
			<dd>在该页面的CSS里已经为所有DIV设置好了2像素的dotted线，并设置好了一定的padding，以便于观察效果。</dd>
			<dd>jQuery代码：</dd>
			<dd>
<code class="ideCode-js">// 对从当前按钮开始遇到的第一个class为“b”的父级进行样式设置
$(".btn").click(function() {
	// 边框变为实线，颜色变为绿色，字体成红色
	$(this).closest(".b").css({
		borderStyle: "solid",
		borderColor: "#0f0",
		color: "#f00"
	});
});</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-010.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-010.html"></iframe>
			</dd>
			<dd>效果稍加观察一目了然，“div.t-4”的边框发生了改变，但class同样含有“b”的“div.t-3”却不会有任何反应。需要注意的是由于字体颜色是一个会继承的CSS属性，导致“div.t-5”内的div字体也发生了改变。不管是现在的closest还是之前的parent和parents在做一些样式操作的时候都要考虑到CSS的继承性问题或父级元素可能对子元素（子元素集）造成的影响。</dd>
			<dd>相对于parents方法来说，closest方法在性能表现上更优。parents是jQuery 1.6版本新增的方法，而closest是jQuery 1.7版本新增的方法，closest方法的出现就是为了解决parents方法会一直遍历到&lt;html&gt;标签带来的性能问题和代码安全度问题。所以，不管从性能角度出发，还是功能的实际需求，如果不是查询当前元素的直接父级，首选都应该是closest方法。</dd>

			<dt>到指定父级为止parentsUntil()</dt>
			<dd>基本语法</dd>
			<dd>
<code class="ideCode-js">$(selector).parentsUntil(param);</code>
			</dd>
			<dd>如果你对之前的prevUntil()和nextUntil()这两个方法还有印象，应该就能猜出parentsUntil()在这里的作用。</dd>
			<dd>首先，该方法通常会设置一个参数，作为遍历停止的节点，并且不包含这个节点。我们仍旧用上例的HTML，从新做一个例子之后就会明白该方法的作用。</dd>
			<dd>jQuery代码：</dd>
			<dd>
<code class="ideCode-js">// 对从当前按钮开始直到“.t-2”为止的父级进行样式设置
$(".btn").click(function() {
	// 边框变为实线，边框颜色和字体颜色都变成变为紫色
	$(this).parentsUntil(".t-2").css({
		borderStyle: "solid",
		borderColor: "#f0f",
		color: "#f0f"
	});
});</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-011.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-011.html"></iframe>
			</dd>
		</dl>
    </section>
    <!-- 章节练习 -->
	<section class="unitPractice">
		<h3>&lt;章节练习一&gt;</h3>
		<p>根据本章之前所学的知识点，完成一个“手风琴菜单”功能，需求细节如下：</p>
		<p>&lt;HTML代码结构&gt;（为节约时间直接复制该段代码即可）</p>
<pre>&lt;div class="leftNavMenu"&gt;
	&lt;ul&gt;
		&lt;li class="checked"&gt;
			&lt;a&gt;域名管理&lt;/a&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;添加域名&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;启动CDN&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;修改所属项目&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;访问控制&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;高级配置&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;
			&lt;a&gt;缓存刷新&lt;/a&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;URL刷新&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;目录刷新&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;操作记录&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;
			&lt;a&gt;统计分析&lt;/a&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;使用量统计&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;访问情况统计&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;状态码统计&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;源站统计&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;全网状态监控&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;运营月报&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;
			&lt;a&gt;高级工具&lt;/a&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;证书管理&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;流量包管理&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;
			&lt;a&gt;诊断工具&lt;/a&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;节点IP归属查询&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;自动故障诊断&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
&lt;/div&gt;
</pre>
		<p>可以<a href="html-pages/jquery/codeEffect/code-007.css" download="selector-01">点击此处</a>下载该示例所需CSS文件，也可以根据自己的能力选择去写属于自己的CSS样式或对下载的CSS文件进行修改。</p>
		<p>主要完成的功能就是：当鼠标点击任意一项的时候，当前列表项“展开”，其它列表项则“收拢”。</p>
		<p>&lt;最终效果大致如图所示&gt;</p>
		<p>
			<img src="img/content/jquery/accordion-menu.gif" title="代码效果示例图" style="border:1px solid #eee;">
		</p>
	</section>
    <!-- 奇偶选择器 -->
    <section>
    	<h3>奇偶选择器</h3>
		<p>基本语法：</p>
		<p>
<code class="ideCode-js">/* 不推荐的形式 */
// 使用CSS3方式的奇数选择
$(selector + ":nth-child(odd)");
// 使用CSS3方式的偶数选择
$(selector + ":nth-child(even)");

/* 推荐的形式 */
// “状态式”奇数选择
$(selector + ":odd");
// “状态式”偶数选择
$(selector + ":even");
</code>
		</p>
		<p>奇偶选择器通常是帮助我们完成表格隔行变色、两列布局时左右功能区分时的一个重要的选择器。当然，CSS3的结构选择器也能完成这一点，并且在jQuery选择器中也可以“照搬”使用，但用于国内浏览器版本使用的情况并不是很理想，CSS3没法在所有的场合中使用。所以，使用jQuery提供的奇偶选择器就是一个非常好的选择了。</p>
		<p>但是有一点是需要注意的，就是CSS里“nth-child”计算奇偶数和我们日常生活中一样，第一个数是从“1”，开始的。而jQuery的奇偶选择器则是计算机语言一贯的风格<em>从0开始计数</em>，也就是说odd（奇数）实际上是我们看到的偶数，而even（偶数）则是我们实际上看到的奇数。在使用的时候千万不要忘记这一点。</p>
		<p>HTML代码：</p>
<code class="ideCode-html"><main class="centerMain">
	<div>1</div>
	<div>2</div>
	<div>3</div>
	<div>4</div>
	<div>5</div>
	<div>6</div>
</main></code>
		<p>CSS代码：</p>
		<p>
<code class="ideCode-css">main.centerMain {
	width: 960px;
	margin: 0 auto;
	border: 1px solid #792c8b;
	overflow: hidden;
}
main.centerMain > div {
	width: 48%;
	height: 50px;
	margin: 10px 0;
	text-align: center;
	font-size: 32px;
	line-height: 50px;
	color: #fff;
	float: left;
}</code>
	</p>
	<p>jQuery代码：</p>
	<p>
<code class="ideCode-js">// 设置索引值为奇数的（CSS中的偶数）div元素的样式
$("main.centerMain > div:odd").css("backgroundColor", "#8b2c54");

// 设置索引值为偶数的（CSS中的偶数）div元素的样式
$("main.centerMain > div:even").css({
	backgroundColor: "#2c498b",
	marginRight: "4%"
});</code>
		</p>
		<p>
			<h4><a href="html-pages/jquery/codeEffect/code-012.html" target="_blank">运行效果</a>：</h4>
			<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-012.html"></iframe>
		</p>
		<p>当然，我们这只是一个jQuery奇偶选择器的例子，实际项目中我们的原则是：能用CSS简单解决的，就不要用JS（这当然包括JS的各种库和框架），能用CSS2解决的，就不要用CSS3（因为存在更多的IE兼容性问题）。</p>
		<p>像上面这个例子，如果用CSS2的方式去做（假设是要兼容IE的情况），就需要给奇偶不同的DIV挂上不同种类的Class，数量少能行得通，但当数量庞大或者是这些DIV标签是动态生成的时候，那还是得用JS去解决。</p>
    </section>
    <!-- 结构性伪类选择器 -->
    <section>
    	<h3>结构性伪类选择器</h3>
		<p>结构性伪类选择器其实指的就是CSS3中的这类选择器，但是部分写法在jQuery中有所简化，只要CSS3这部分的选择器掌握了，那jQuery这类选择器也就掌握了。下面我们以&lt;li&gt;标签为例，列出这些结构性伪类选择器。</p>
		<p>
<code class="ideCode-js">// 各个父级下的第一个子元素
$("li:first");
$("li").first();
$("li:first-child");
// 各个父级下的第一个子元素的类型
$("li:first-of-type");

// 各个父级下的最后一个子元素
$("li:last");
$("li").last();
$("li:last-child");
// 各个父级下的最后一个子元素的类型
$("li:last-of-type");

// 各个父级下排除指定的子元素
$("li:not(select)");

// 各个父级下的第n个元素
$("li:nth-child(n)");
// 各个父级下的第n个类型的元素
$("li:nth-of-type(n)");

// 各个父级下的倒数第n个元素
$("li:nth-last-child(n)");
// 各个父级下的倒数第n个类型的元素
$("li:nth-last-of-type(n)");

// 各个父级下唯一的元素
$("li:only-child");
// 各个父级下唯一类型的元素
$("li:only-of-type");
</code>
		</p>
		<p>这些选择器多而杂，没必要完全地记住每一个，只需要记住简单，更符合jQuery语法结构，且兼容性比较好的即可，拿前两类的来说：“$("li").first()”和“$("li").last()”更符合jQuery的语法格式，兼容性也比较不错。“$("li:first")”这样的类型更简单，兼容性和前者也一样，但可读性不如前者。当然，这只是推荐，实际运用中可根据个人的编码风格决定，但原则是，无论写什么样的代码都应该保证<em>可读性</em>和<em>兼容性</em>。</p>
    </section>
    <!-- 状态选择器 -->
    <section>
    	<h3>状态选择器</h3>
		<p>状态选择器同样</p>
    </section>
    <!-- 表单元素选择器 -->
    <section>
    	<h3>表单元素选择器</h3>
		<p></p>
    </section>
    <!-- 索引选择器 -->
    <section>
    	<h3>索引选择器</h3>
		<p></p>
    </section>
    <!-- 动画元素选择器 -->
    <section>
    	<h3>动画元素选择器</h3>
		<p></p>
    </section>
    <!-- 哈希目标选择器 -->
    <section>
    	<h3>哈希目标选择器</h3>
		<p></p>
    </section>
    <!-- 元素判断 -->
    <section>
    	<h3>元素判断</h3>
		<p>is()</p>
    </section>
    <!-- 文本包含选择器 -->
    <section>
    	<h3>文本包含选择器</h3>
		<p>$("div:contains");</p>
    </section>
    <!-- 标签包含选择器 -->
    <section>
    	<h3>标签包含选择器</h3>
		<p>$("div:has(p)");</p>
		<p>$("div").has(p);</p>
    </section>
    <!-- 文本或标签包含选择器 -->
    <section>
    	<h3>文本或标签包含选择器</h3>
		<p>$("div:parent");</p>
    </section>
    <!-- 包含元素筛选选择器 -->
    <section>
    	<h3>包含元素筛选选择器</h3>
		<p></p>
    </section>
    <!-- 空内容选择器 -->
    <section>
    	<h3>空内容选择器</h3>
		<p></p>
    </section>
</root>



