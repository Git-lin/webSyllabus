<root data-root="jQuery选择器">
	<!-- jQuery选择器概述 -->
	<section class="mt0">
    	<h3>jQuery选择器概述</h3>
    	<p>jQuery的选择器实现的根源当然还是DOM，但对选择器简化的灵感来源却是CSS，jQuery发展到现在这个版本，CSS3能做到的，jQuery基本上都能做到（:before、:after除外），如：元素选择器，ID选择器、class选择器、属性选择器、结构选择器、状态选择器，UI伪元素选择器等等。不仅如此，jQuery还提供了一些CSS办不到，JavaScript+DOM也不能一句话搞定的选择器。如：文本包含选择器、标签包含选择器、包含元素筛选选择器等。</p>
    	<p>由于jQuery“诞生”的日子比较早（2006年），它的很多做法受到了其它各类库的效仿，当然jQuery也从其它库的身上“要来”不少东西，如火热一时的<em title="该库目前已经在朝着Web应用框架方向转型了">MooTools</em>。jQuery的设计模式刚出来的时候就收到业界的高度重视，在它诞生的第二年，其内容就成为很多计算机高校必修或选修的课程，这种情况就现在看来都是不可思议的。</p>
    	<p>选择器作为jQuery的核心内容，更是被很多JS库所效仿。甚至可以很不负责任的说，就连原生的JavaScript和DOM都深受其影响，如getElementsByClassName这个ECMAScript 2010（简称ES5）才出现的选择器，以及紧跟着出现的querySelector()和querySelectorAll()这两个像极了jQuery的DOM选择器。</p>
    	<p><em>Sizzle</em>是jQuery的开发者John Resig新编写的一个JavaScript选择器，速度号称业界第一。它在2009年1月14日的时候导入了jQuery的核心，使得jQuery更加的强大。该作者根据ES5及一些外来的灵感在2012年8月9日的时候发布了重写的Sizzle，这使得jQuery的性能更加强大。当然，Sizzle一直也作为独立的版本存在着，如果不想使用jQuery，也可以单独下载Sizzle，它的体积比jQuery要小得多。</p>
    	<p>和DOM选择器一样，jQuery的选择器参数部分是以字符串的形式存在的，所以允许变量或字符串与变量拼接的形式。如：</p>
    	<p>
<code class="ideCode-js">// 置空所有的文本框的值
$("input").val("");

// 将用户名输入框的值设置为“aulence”
var getName = "aulence";
$("#userName").val(getName);

// 将id为“userInfo”元素的文本内容设置为“用户信息”
var ele = "userInfo";
$("#" + ele).text("用户信息");

// 将class为“showParg”的元素的内容替换为一个“段落文本内容”的p标签
var parag = ".showParg";
$(parag).html("&lt;p&gt;段落文本内容&lt;/p&gt;");</code>
   		</p>
   		<p>关于jQuery课程中“代码显示器”（JS部分）中的代码颜色的一些约定规则：</p>
		<ul class="indent">
			<li>“<em>关键字</em>”代码颜色用<i class="diamond" style="background-color:#ff3f77"></i>色进行表示</li>
			<li>“<em>内置对象</em>”（包括BOM/DOM/函数）代码颜色用<i class="diamond" style="background-color:#ff6d6d"></i>色进行表示</li>
			<li>“<em>变量名</em>”代码颜色用<i class="diamond" style="background-color:#ee6aff"></i>色进行表示</li>
			<li>“<em>方法名</em>”代码颜色用<i class="diamond" style="background-color:#51ebff"></i>色进行表示</li>
			<li>“<em>对象属性名（键名）</em>”代码颜色用<i class="diamond" style="background-color:#6c9fff"></i>色进行表示</li>
			<li>“<em>字符串</em>”代码颜色用<i class="diamond" style="background-color:#ece077"></i>色进行表示</li>
			<li>“<em>代码注释</em>”代码颜色用<i class="diamond" style="background-color:#00ff7f"></i>色进行表示</li>
			<li>“抽象词”或“特殊词”代码颜色用<i class="diamond" style="background-color:#b9ff00"></i>色进行表示（“抽象词”就是用于概括表示某一类代码的词，并非真正的功能性代码，实际使用中需替换为正确格式的代码单词或字符串，而“特殊词”指有一定特殊含义的词）</li>
		</ul>
		<p>当然，这些规定不需要去记忆。只是当无法区分某段代码中的某个代码单词的作用时可以方便在这里查询。</p>
    </section>

    <!-- 元素选择器 -->
	<section>
    	<h3>元素选择器</h3>
    	<p>基本语法：</p>
    	<p>
<code class="ideCode-js">$(TagName).method(function() {
	// 需要做的事
});</code>
   		</p>
   		<p>示例中的“TagName”指的是标签名，在实际使用中记得加上引号。如果有多个标签名，可以用英文逗号进行分割，如例：</p>
   		<p>
<code class="ideCode-js">$("div,p,span").css("color", "#3d3d3d");</code>
   		</p>
   		<p>上例的实现的效果是，同时将div、p和span三个标签的字体颜色设置为“#3d3d3d”。</p>
   		<p>jQuery的元素选择器（标签选择器）和DOM的选择器产生作用的区别在于，jQuery选择器不需要给元素加上索引下标即可选中页面中所有的标签，而DOM需要通过一次循环来实现所有元素标签的选择遍历。其实jQuery的选择器也会进行一次内部的循环遍历，只不过这样的操作不需要开发者来进行了而已。</p>
    </section>

    <!-- ID选择器 -->
    <section>
    	<h3>ID选择器</h3>
		<p>基本语法：</p>
    	<p>
<code class="ideCode-js">$("#" + ID).method(function() {
	// 需要做的事
});</code>
		</p>
   		<p>和标签选择器一样，如果要对多个ID进行操作需要用英文逗号进行分割，如例：</p>
   		<p>
<code class="ideCode-js">$("#userName, #userPwd").val("");</code>
   		</p>
   		<p>上例的实现的效果是，将ID为“userName”和“userPwd”的输入框（只有表单元素才能使用val()方法）的值置空。ID是唯一的，所以不会对选择器进行遍历，若页面中存在多个同名ID，则只会选择第一个。所以，ID选择器无论是在JavaScript中还是在jQuery中，都是最快的一种选择器。但需要提醒的是，前端开发其实是应该尽量避免过多的ID出现的，特别是那些只是用于布局或视觉样式操作的ID更是没有必要了。这样只会带来名称管理的负担，ID无论在什么时候都应该体现出其唯一性的特点。</p>
    </section>

    <!-- Class选择器 -->
    <section>
    	<h3>Class选择器</h3>
		<p>又称“<em>类选择器</em>”，基本语法：</p>
    	<p>
<code class="ideCode-js">$("." + ID).method(function() {
	// 需要做的事
});</code>
		</p>
   		<p>和元素选择器、ID选择器一样，Class选择器也能同时一次性选择多个Class。</p>
   		<p>
<code class="ideCode-js">$(".mainNav, .leftName, .footerNav").css("text-decoration", "none");</code>
		</p>
   		<p>并且该选择器和元素选择器一样会在jQuery核心代码的内部执行一次循环将所有同名的Class都进行选择。</p>
    </section>
    <section>
    	<h3>属性选择器</h3>
		<p>和CSS一样，jQuery也能通过元素的属性进行选择。基本语法：</p>
   		<p>
<code class="ideCode-js">$([AttributeName]).method(function() {
	// 需要做的事
});</code>
		</p>
   		<p>当然，CSS选择器能做到的jQuery自然也不会含糊，如：</p>
   		<p>
<code class="ideCode-js">$("div[data-info]");
$("div[data-info='roleInfo']");
$("input[type='radio']");
$("img[title^='简约风...']");
$("input[placeholder*='请输入']");
// 等等...</code>
		</p>
   		<p>也就是说，只要CSS能使用的属性选择器，jQuery也能使用。只需要将CSS的选择器直接复制过来就能使用，当然，不要忘了jQuery的所有选择器都需要用一对引号括起来，变量例外，不过得保证变量也是一个字符串。</p>
    </section>

    <!-- 子元素和后代选择器 -->
    <section>
    	<h3>子元素和后代选择器</h3>
		<p>基本语法：</p>
		<p>
<code class="ideCode-js">// 子元素选择器
$("selector &gt; selector").method(function() {
	// 需要处理事件A
});

// 后代元素选择器
$("selector selector").method(function() {
	// 需要处理事件B
});

// 子元素选择器实例
$("div &gt; p").method(function() {
	// 要处理的事件C
});

// 后代元素选择器实例
$("form input").method(function() {
	// 需要处理事件D
});
</code>
		</p>
		<p>这和我们平时使用CSS选择器也是一样的，而jQuery提供的后代选择器方法和子元素选择器方法则有所不同，它可以处理更多的未知性，并且有一定的查询作用。jQuery查询子元素主要提供两个方法：</p>
		<dl class="attrExplain">
			<dt>子元素查询children()</dt>
			<dd>基本语法</dd>
			<dd>
<code class="ideCode-js">// 子元素查询
$("selector").children(param);

// 查找form标签下的div下的全部input表单元素，并添加获得焦点事件
$("form div").children("input").focus(function() {
	// 需要处理的事件
});

// 将div下面所有标签的字体大小设置为16像素
$("div").children().css("font-size", "16px");
</code>
			</dd>
			<dd>该方法的参数是一个可选项，当不给参数的时候，它能选择当前元素下的“直接子元素”，这相当于是CSS里的“parent &gt; child”，不同的是CSS必须给出“child”的选择器名，而jQuery则不用。这个区别产生的实际意义就是，CSS必须指定某个子元素，而不能选择全部子元素，而jQuery可以指定某个子元素，也可以选择全部子元素</dd>

			<dt>后代元素查询find()</dt>
			<dd>基本语法</dd>
			<dd>
<code class="ideCode-js">// 子元素查询
$("selector").find(param);

// 查找header内是在单独窗口打开超链接的a标签，并添加一个类名newWin
$("header").find("a[target='_blank']").addClass("newWin");

// 将ul内所有li（可能存在列表嵌套）找出并添加点击后弹出当前li文本的功能
$("ul").find("li").click(function(){
	var liText = $(this).text();
	alert(liText);
});
</code>
			</dd>
			<dd>和children方法一样该方法的参数是一个可选项，当不给参数的时候，它能选择当前元素下的所有子元素，这相当于是CSS里的“parent child”，至于区别也和children方法与CSS之间是一样的。</dd>
			<dd>但这里需要特别说明，由于find方法会将当前元素的所有子元素节点都进行一次遍历，也就说当前元素子元素节点数量过大的话，带来的性能损耗是相当大的，有的时候宁愿连续用两次children方法都不要用一次find方法，从代码节点控制的严谨性上来讲，children方法也是要优于find方法的。</dd>
		</dl>
    </section>
    <section>
    	<h3>同级选择器</h3>
		<p>虽然CSS官方的翻译是“同级、同胞选择器”，但是我们知道无论是CSS里的“+”还是“~”选择符都只能选择器当前节点之后的同级元素。</p>
   		<p>选择当前元素相邻的下一个同级元素的jQuery选择器写法为：</p>
   		<p>
<code class="ideCode-js">$("li + li").method(param);</code>
		</p>
   		<p>而选择当前元素之后所有的同级元素的jQuery选择器写法为：</p>
   		<p>
<code class="ideCode-js">$("li ~ li").method(param);</code>
		</p>
   		<p>这和我们使用CSS的选择符进行元素的选择没有任何区别。但实际上，这两个选择符在jQuery里面是很少出现的，因为jQuery有更好的选择器同级元素的方法，而且性能表现上由于会省略掉正则判断一环，所以是一种更佳的选择器。</p>
   		<p>接下来我们就来介绍jQuery里的这些同级元素选择器。</p>
   		<dl class="attrExplain">
   			<dt>上一个同级元素prev()</dt>
   			<dd>基本语法：</dd>
   			<dd>
<code class="ideCode-js">$("selector").prev();</code>
   			</dd>
   			<dd>该方法不需要参数，因为这个方法能选到的元素节点是唯一的。如果找不到上一个元素节点，则会返回一个length为0的jQuery对象。没有办法使用现有的CSS选择器来实现该功能。</dd>

			<dt>下一个同级元素next()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$("selector").next();</code>
			</dd>
			<dd>该方法和prev()相比，只是选择的是当前元素的下一个元素节点，其它特性基本一致。</dd>

			<dt>之前的同级元素prevAll()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$("selector").prevAll(param);</code>
			</dd>
			<dd>该方法的参数为一个字符串，设置内容为CSS选择器，可选填。当参数为空的时候表示的当前元素之前所有的统计元素，当设置参数的时候必须是一个字符串或存有字符串的变量（可以使用变量+字符串的拼接操作），和jQuery选择器一样使用CSS选择器作为参数内容，这样就会返回当前元素之前指定选择器的节点。</dd>
			<dd>我们通过一个示例来理解该方法的功能，现有如下HTML代码：</dd>
			<dd>
<code class="ideCode-html">&lt;ul class="skill-list"&gt;
	&lt;li class="html"&gt;HTML&lt;/li&gt;
	&lt;li class="css"&gt;CSS&lt;/li&gt;
	&lt;li class="js"&gt;JavaScript&lt;/li&gt;
	&lt;li class="jq"&gt;jQuery&lt;/li&gt;
	&lt;li class="ng"&gt;Angular&lt;/li&gt;
	&lt;li class="rc"&gt;React&lt;/li&gt;
	&lt;li class="v"&gt;Vue&lt;/li&gt;
&lt;/ul&gt;</code>
			</dd>
			<dd>jQuery代码如下：</dd>
			<dd>
<code class="ideCode-js">// 点击列表项后使之前的列表项编程橙色
$(".skill-list > li").click(function() {
	$(this).prevAll().css("color", "#f80");
});</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-003.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-003.html" ></iframe>
			</dd>
			<dd>效果还是比较直观的，点击列表项的时候，当前项没有效果，当前项之前的列表项都会生效。现在我们为prevAll方法加上一个".css"选择器作为参数，这样无论点击class为“css”之后的哪一项，拥有“css”的项都会生效颜色变化代码。</dd>
			<dd>
<code class="ideCode-js">// 点击CSS之后的列表项，CSS项都会变成蓝色，而点击CSS或之前的项则不会有任何效果
$(".skill-list > li").click(function() {
	// prevAll方法内只能传入一个CSS选择器
	$(this).prevAll(".css").css("color", "#00f");
});</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-004.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-004.html" ></iframe>
			</dd>
			<dd>如果当前元素之前没有元素节点，则会返回一个length为0的jQuery对象。另外，还需要注意的一个小细节就是这类方法（后面出现的nextAll、prevUntil、nextUntil也是一样的）的匹配结果的顺序是从当前标签开始的一个“由近到远”的jQuery对象数组。例如，点击上例中的“jQuery”列表项并使用prevAll不带参数的遍历，出来的结果是“JavaScript → CSS → HTML”这样的顺序，了解这点，对我们以后实现一些复杂需求有思维上的帮助。</dd>

			<dt>之后的同级元素nextAll()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$("selector").nextAll(param);</code>
			</dd>
			<dd>方法和prevAll()相比，只是选择的是当前元素之后的元素节点，其它特性基本一致。</dd>

			<dt>之前的第一个同级匹配元素prevUntil()</dt>
			<dd>该方法用于匹配当前元素之前一直到满足匹配条件之间（不包括这个元素）的同级元素，基本语法：</dd>
			<dd>
<code class="ideCode-js">$("selector").prevUntil(param);</code>
			</dd>
			<dd>该方法的参数虽然是可选项，但总是建议传入参数，否则它和不带参数的prevAll方法几乎没有区别，也达不到我们使用它的目的。我们用这个方法来实现一个如下一个功能。</dd>
			<dd>HTML代码示例：</dd>
			<dd>
<code class="ideCode-html">&lt;main&gt;
	&lt;h3&gt;水果类&lt;/h3&gt;
	&lt;p&gt;苹果&lt;/p&gt;
	&lt;p&gt;梨子&lt;/p&gt;
	&lt;p&gt;香蕉&lt;/p&gt;
	&lt;p class="describe"&gt;补充维生素ABCDEFG&lt;/p&gt;
	&lt;h3&gt;零食类&lt;/h3&gt;
	&lt;p&gt;辣条&lt;/p&gt;
	&lt;p&gt;薯片&lt;/p&gt;
	&lt;p&gt;饼干&lt;/p&gt;
	&lt;p class="describe"&gt;杀死维生素ABCDEFG&lt;/p&gt;
	&lt;h3&gt;肉类&lt;/h3&gt;
	&lt;p&gt;牛肉&lt;/p&gt;
	&lt;p&gt;猪肉&lt;/p&gt;
	&lt;p&gt;羊肉&lt;/p&gt;
	&lt;p class="describe"&gt;补充蛋白质、能量、纤维素&lt;/p&gt;
&lt;/main&gt;</code>
			</dd>
			<dd>jQuery代码示例：</dd>
			<dd>
<code class="ideCode-js">// 点击当前p元素之后，一直到h3为止的元素都变成紫色
$("p").click(function() {
	$(this).prevUntil("h3").css("color", "#f0f");
});
</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-005.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-005.html" ></iframe>
			</dd>
			<dt>后前的第一个同级匹配元素nextUntil()</dt>
			<dd>该方法用于匹配当前元素之后一直到满足匹配条件之间（不包括这个元素）的同级元素，基本语法：</dd>
			<dd>
<code class="ideCode-js">$("selector").nextUntil(param);</code>
			</dd>
			<dd>该方法和prevUntil特性完全一样，只是匹配的元素是从当前元素开始之后的元素而已。</dd>
			<dt>同级兄弟节点siblings()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$("selector").siblings(param);</code>
			</dd>
			<dd>该方法的参数也是可选的，当不配置参数的时候该方法会匹配到除当前选择器节点以外的其它节点，而配置参数之后，那它就会去配置参数内配置的选择器节点。该方法在很多场合下都非常好用，如制作一个拥有被点选效果的按钮组或导航。</dd>
			<dd>HTML代码示例：</dd>
			<dd>
<code class="ideCode-html">&lt;nav&gt;
	&lt;!-- 默认让列表中第一项“选中”（其实只是一个CSS样式而已）--&gt;
	&lt;ul class="mainNav"&gt;
		&lt;li class="checked"&gt;英雄联盟&lt;/li&gt;
		&lt;li&gt;王者荣耀&lt;/li&gt;
		&lt;li&gt;穿越火线&lt;/li&gt;
		&lt;li&gt;地下城与勇士&lt;/li&gt;
		&lt;li&gt;魔兽世界&lt;/li&gt;
		&lt;li&gt;梦幻西游&lt;/li&gt;
		&lt;li&gt;炉石传说&lt;/li&gt;
	&lt;/ul&gt;
&lt;/nav&gt;</code>
			</dd>
			<dd>jQuery代码示例：</dd>
			<dd>
<code class="ideCode-js">// 当行点击选中效果
$("nav > ul.mainNav > li").click(function() {
	// 当前元素添加指定class，其它所有兄弟元素则移除这个class
	// “checked”这个class是我们在CSS里预先设置好样式的
	$(this).addClass("checked").siblings().removeClass("checked");
});
</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-006.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-006.html" ></iframe>
			</dd>
			<dd>这样一个功能，若要用原生的JavaScript去进行还原，单是第一个选择器部分“$("nav > ul.mainNav > li")”就得耗费不少代码，还得考虑用一个循环给这些节点绑定事件。进入到添加/移除选中效果的时候还得用一个循环或者节点精确查找的方式去移除上一次被选中选中的class。各种循环判断下来，初步估计5行或以上的代码是少不了的，而且由于JS语法属性名称关系，每行的字节量还不会少。然而，这样一个需要涉及多处小逻辑的功能，用jQuery竟然两行有效代码就搞定了，这里面“siblings()”方法“功不可没”。</dd>
			<dd>请在自己的编辑器里进行实践以加深对本节方法的理解，并务必花时间思考这些方法在实际运用中可以帮助我们完成那些工作。</dd>
    	</dl>
    </section>

    <!-- 父级选择器 -->
    <section>
    	<h3>父级选择器</h3>
		<p>在CSS中没有可以选择父级的选择器，所以jQuery也没有办法像之前的选择器那样提供可以查询父级的CSS选择器，但是jQuery提供了三个方法来查询选择父级（祖先级）元素，这三个方法配合之前所学选择器方法基本可以应付各种节点选择的情况了。</p>
		<dl class="attrExplain">
			<dt>选择直接父级parent()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$("selector").parent();</code>
			</dd>
			<dd>该方法不需要加上参数，因为每个节点的父级是唯一的。若加上了一个选择器字符串作为参数，如果参数指的就是父级那和不加参数没有任何区别，若参数指的不是当前节点的父级，那返回的是一个length为0的jQuery对象。虽然说可以利用这一点来判断一个元素的父级是否是某个元素，但并不推荐这样用。一般我们都是用<em>is()</em>方法来判断当前元素是否是我们制定的某个元素，这在我们本章中会进行讲解。</dd>

			<dt>选择全部或指定父级集合parents()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$("selector").parents(param);</code>
			</dd>
			<dd>该方法除了有一个可选参数（通常都会设置该参数），和直接父元素选择器parent相比，这个方法只是多了一个字母“s”，由此可见，该方法返回的是一个集合。当然，这个集合和我们对JS中数组的理解还是有些差别的，因为如果使用jQuery方法来操作这个集合也是不需要进行循环的。我们还是通过一个例子来进行说明：</dd>
			<dd>HTML代码示例：</dd>
			<dd>
<code class="ideCode-html">&lt;body&gt;
	&lt;main class="a"&gt;
		&lt;article class="a b"&gt;
			&lt;h1&gt;文章的标题&lt;/h1&gt;
			&lt;section class="a b c"&gt;
				&lt;h2&gt;二级标题&lt;/h2&gt;
				&lt;p&gt;正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容...&lt;/p&gt;
				&lt;p&gt;正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容...&lt;/p&gt;
			&lt;/section&gt;
			&lt;section class="a b c"&gt;
				&lt;h2&gt;二级标题&lt;/h2&gt;
				&lt;p&gt;正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容...&lt;/p&gt;
				&lt;p&gt;正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容...&lt;/p&gt;
			&lt;/section&gt;
		&lt;/article&gt;
	&lt;/main&gt;
&lt;/body&gt;</code>
			</dd>
			<dd>jQuery代码示例：</dd>
			<dd>
<code class="ideCode-js">// 点击段落为所有的父级添加红色边框
$("p").click(function() {
	$(this).parents().css("border", "1px solid #f00");
	// 观察点击事件后控制台中输出的结果
	console.log($(this).parents());
});</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-008.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-008.html"></iframe>
			</dd>
			<dd>通过示例可以发现（在浏览器开发者工具中的“Elements”中观察结构详情），当段落标签被点击之后，只要是p标签父级的元素都加上的红色的边框，而且在控制台中输出了这个父级的集合。</dd>
			<dd>在开发者工具中可以清晰地看到HTML（document）的层次结构：</dd>
			<dd><img src="img/content/jquery/parents-list.jpg" title="Google Chrome控制台Elements" style="border:1px solid #eee;"></dd>
			<dd>再来看一个例子：</dd>
			<dd>
<code class="ideCode-js">// 点击段落让main的宽度设为760像素，背景色变为墨绿色，且水平居中
$("p").click(function() {
	$(this).parents("main.a").css({
		width: "760px",
		backgroundColor: "#08957f",
		margin: "0 auto"
	});
	// 观察点击事件后控制台中输出的结果
	console.log($(this).parents("main.a"));
});</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-009.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-009.html"></iframe>
			</dd>
			<dd>这回输出的结果只有一个，因为满足parents方法内参数选择器既是main标签，而且Class又是“a”的，从当前的结构上来讲只有唯一的一个。由此，可以自行完成一个小测试，将class为“b”的元素设置为1像素实线的红色边框，并在控制台中将这个parents的集合输出来看看。（由于保证示例显示效果，代码中已经设置过每个元素的padding值，这里自行设置即可）</dd>

			<dt>选择指定父级closest()</dt>
			<dd>基本语法</dd>
			<dd>
<code class="ideCode-js">$("selector").closest(param);</code>
			</dd>
			<dd>该方法同样是选择父级，但参数是一个<em>必填项</em>，否则将返回一个length为0的空jQuery对象，也无法实现我们预期的功能了。closest方法选择父级有2个特点：</dd>
			<ul>
				<li>所需查询的父级不一定是当前元素节点的直接父级</li>
				<li>查询顺序是从当前节点开始，遇到的第一个符合条件的父级，也就是说结果是唯一的</li>
			</ul>
			<dd>还是通过一个示例来了解closest()方法，HTML如下：</dd>
			<dd>
<code class="ideCode-html">&lt;div class="t-1 a"&gt;
	&lt;div&gt;t-1&lt;/div&gt;
	&lt;div class="t-2 a"&gt;
		&lt;div&gt;t-2&lt;/div&gt;
		&lt;div class="t-3 b"&gt;
			&lt;div&gt;t-3&lt;/div&gt;
			&lt;div class="t-4 b"&gt;
				&lt;div&gt;t-4&lt;/div&gt;
				&lt;div class="t-5"&gt;
					&lt;div&gt;t-5&lt;/div&gt;
					&lt;button class="btn" type="button"&gt;按钮&lt;/button&gt;
				&lt;/div&gt;
			&lt;/div&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/div&gt;</code>
			</dd>
			<dd>在该页面的CSS里已经为所有DIV设置好了2像素的dotted线，并设置好了一定的padding，以便于观察效果。</dd>
			<dd>jQuery代码：</dd>
			<dd>
<code class="ideCode-js">// 对从当前按钮开始遇到的第一个class为“b”的父级进行样式设置
$(".btn").click(function() {
	// 边框变为实线，颜色变为绿色，字体成红色
	$(this).closest(".b").css({
		borderStyle: "solid",
		borderColor: "#0f0",
		color: "#f00"
	});
});</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-010.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-010.html"></iframe>
			</dd>
			<dd>效果稍加观察一目了然，“div.t-4”的边框发生了改变，但class同样含有“b”的“div.t-3”却不会有任何反应。需要注意的是由于字体颜色是一个会继承的CSS属性，导致“div.t-5”内的div字体也发生了改变。不管是现在的closest还是之前的parent和parents在做一些样式操作的时候都要考虑到CSS的继承性问题或父级元素可能对子元素（子元素集）造成的影响。</dd>
			<dd>相对于parents方法来说，closest方法在性能表现上更优。parents是jQuery 1.6版本新增的方法，而closest是jQuery 1.7版本新增的方法，closest方法的出现就是为了解决parents方法会一直遍历到&lt;html&gt;标签带来的性能问题和代码安全度问题。所以，不管从性能角度出发，还是功能的实际需求，如果不是查询当前元素的直接父级，首选都应该是closest方法。</dd>

			<dt>到指定父级为止parentsUntil()</dt>
			<dd>基本语法</dd>
			<dd>
<code class="ideCode-js">$("selector").parentsUntil(param);</code>
			</dd>
			<dd>如果你对之前的prevUntil()和nextUntil()这两个方法还有印象，应该就能猜出parentsUntil()在这里的作用。</dd>
			<dd>首先，该方法通常会设置一个参数，作为遍历停止的节点，并且不包含这个节点。我们仍旧用上例的HTML，从新做一个例子之后就会明白该方法的作用。</dd>
			<dd>jQuery代码：</dd>
			<dd>
<code class="ideCode-js">// 对从当前按钮开始直到“.t-2”为止的父级进行样式设置
$(".btn").click(function() {
	// 边框变为实线，边框颜色和字体颜色都变成变为紫色
	$(this).parentsUntil(".t-2").css({
		borderStyle: "solid",
		borderColor: "#f0f",
		color: "#f0f"
	});
});</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-011.html" target="_blank">运行效果</a>：</h4>
				<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-011.html"></iframe>
			</dd>
		</dl>
    </section>

    <!-- 章节练习 -->
	<section class="unitPractice">
		<h3>&lt;章节练习一&gt;</h3>
		<p>根据本章之前所学的知识点，完成一个“手风琴菜单”功能，需求细节如下：</p>
		<p>&lt;HTML代码结构&gt;（为节约时间直接复制该段代码即可）</p>
<pre>&lt;div class="leftNavMenu"&gt;
	&lt;ul&gt;
		&lt;li class="checked"&gt;
			&lt;a&gt;域名管理&lt;/a&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;添加域名&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;启动CDN&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;修改所属项目&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;访问控制&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;高级配置&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;
			&lt;a&gt;缓存刷新&lt;/a&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;URL刷新&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;目录刷新&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;操作记录&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;
			&lt;a&gt;统计分析&lt;/a&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;使用量统计&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;访问情况统计&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;状态码统计&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;源站统计&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;全网状态监控&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;运营月报&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;
			&lt;a&gt;高级工具&lt;/a&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;证书管理&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;流量包管理&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;
			&lt;a&gt;诊断工具&lt;/a&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;节点IP归属查询&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;自动故障诊断&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
&lt;/div&gt;
</pre>
		<p>可以<a href="html-pages/jquery/codeEffect/code-007.css" download="selector-01">点击此处</a>下载该示例所需CSS文件，也可以根据自己的能力选择去写属于自己的CSS样式或对下载的CSS文件进行修改。</p>
		<p>主要完成的功能就是：当鼠标点击任意一项的时候，当前列表项“展开”，其它列表项则“收拢”。</p>
		<p>&lt;最终效果大致如图所示&gt;</p>
		<p>
			<img src="img/content/jquery/accordion-menu.gif" title="代码效果示例图" style="border:1px solid #eee;">
		</p>
	</section>

    <!-- 奇偶选择器 -->
    <section>
    	<h3>奇偶选择器</h3>
		<p>基本语法：</p>
		<p>
<code class="ideCode-js">/* 不推荐的形式 */
// 使用CSS3方式的奇数选择
$("selector:nth-child(odd)");
// 使用CSS3方式的偶数选择
$("selector:nth-child(even)");

/* 推荐的形式 */
// “状态式”奇数选择
$("selector:odd");
// “状态式”偶数选择
$("selector:even");
</code>
		</p>
		<p>奇偶选择器通常是帮助我们完成表格隔行变色、两列布局时左右功能区分时的一个重要的选择器。当然，CSS3的结构选择器也能完成这一点，并且在jQuery选择器中也可以“照搬”使用，但用于国内浏览器版本使用的情况并不是很理想，CSS3没法在所有的场合中使用。所以，使用jQuery提供的奇偶选择器就是一个非常好的选择了。</p>
		<p>但是有一点是需要注意的，就是CSS里“nth-child”计算奇偶数和我们日常生活中一样，第一个数是从“1”，开始的。而jQuery的奇偶选择器则是计算机语言一贯的风格<em>从0开始计数</em>，也就是说odd（奇数）实际上是我们看到的偶数，而even（偶数）则是我们实际上看到的奇数。在使用的时候千万不要忘记这一点。</p>
		<p>HTML代码：</p>
<code class="ideCode-html"><main class="centerMain">
	<div>1</div>
	<div>2</div>
	<div>3</div>
	<div>4</div>
	<div>5</div>
	<div>6</div>
</main></code>
		<p>CSS代码：</p>
		<p>
<code class="ideCode-css">main.centerMain {
	width: 960px;
	margin: 0 auto;
	border: 1px solid #792c8b;
	overflow: hidden;
}
main.centerMain > div {
	width: 48%;
	height: 50px;
	margin: 10px 0;
	text-align: center;
	font-size: 32px;
	line-height: 50px;
	color: #fff;
	float: left;
}</code>
	</p>
	<p>jQuery代码：</p>
	<p>
<code class="ideCode-js">// 设置索引值为奇数的（CSS中的偶数）div元素的样式
$("main.centerMain > div:odd").css("backgroundColor", "#8b2c54");

// 设置索引值为偶数的（CSS中的偶数）div元素的样式
$("main.centerMain > div:even").css({
	backgroundColor: "#2c498b",
	marginRight: "4%"
});</code>
		</p>
		<p>
			<h4><a href="html-pages/jquery/codeEffect/code-012.html" target="_blank">运行效果</a>：</h4>
			<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-012.html"></iframe>
		</p>
		<p>当然，我们这只是一个jQuery奇偶选择器的例子，实际项目中我们的原则是：能用CSS简单解决的，就不要用JS（这当然包括JS的各种库和框架），能用CSS2解决的，就不要用CSS3（因为存在更多的IE兼容性问题）。</p>
		<p>像上面这个例子，如果用CSS2的方式去做（假设是要兼容IE的情况），就需要给奇偶不同的DIV挂上不同种类的Class，数量少能行得通，但当数量庞大或者是这些DIV标签是动态生成的时候，那还是得用JS去解决。</p>
    </section>

    <!-- 结构性伪类选择器 -->
    <section>
    	<h3>结构性伪类选择器</h3>
		<p>结构性伪类选择器其实指的就是CSS3中的这类选择器，但是部分写法在jQuery中有所简化，只要CSS3这部分的选择器掌握了，那jQuery这类选择器也就掌握了。下面我们以&lt;li&gt;标签为例，列出这些结构性伪类选择器。</p>
		<p>
<code class="ideCode-js">// 各个父级下的第一个子元素
$("li:first");
$("li").first();
$("li:first-child");

// 各个父级下的第一个子元素的类型
$("li:first-of-type");

// 各个父级下的最后一个子元素
$("li:last");
$("li").last();
$("li:last-child");

// 各个父级下的最后一个子元素的类型
$("li:last-of-type");

// 各个父级下排除指定的子元素
$("li:not(select)");

// 各个父级下的第n个元素
$("li:nth-child(n)");

// 各个父级下的第n个类型的元素
$("li:nth-of-type(n)");

// 各个父级下的倒数第n个元素
$("li:nth-last-child(n)");

// 各个父级下的倒数第n个类型的元素
$("li:nth-last-of-type(n)");

// 各个父级下唯一的元素
$("li:only-child");

// 各个父级下唯一类型的元素
$("li:only-of-type");
</code>
		</p>
		<p>这些选择器多而杂，没必要完全地记住每一个，只需要记住简单，更符合jQuery语法结构，且兼容性比较好的即可，拿前两类的来说：“$("li").first()”和“$("li").last()”更符合jQuery的语法格式，兼容性也比较不错。“$("li:first")”这样的类型更简单，兼容性和前者也一样，但可读性不如前者。当然，这只是推荐，实际运用中可根据个人的编码风格决定，但原则是，无论写什么样的代码都应该保证<em>可读性</em>和<em>兼容性</em>。</p>
    </section>

    <!-- 状态选择器 -->
    <section>
    	<h3>表单元素选择器</h3>
		<p>表单元素选择器有点像是CSS标签选择器+[type="form-element"]的形式，基本语法如下：</p>
		<p>
<code class="ideCode-js">// 文本框
$("input:text");

// 密码框
$("input:password");

// 类型为按钮的按钮元素（按钮有“button/reset/submit”几种类型）
$("button:button");
</code>
		</p>
		<p>到目前为止，jQuery中所有可用的表单元素选择器如下：</p>
		<ul class="indent">
			<li>:input —— 所有的&lt;input&gt;元素</li>
			<li>:text —— type属性为“text”的&lt;input&gt;元素</li>
			<li>:password —— type属性为“password”的&lt;input&gt;元素</li>
			<li>:radio —— type属性为“radio”的&lt;input&gt;元素</li>
			<li>:checkbox —— type属性为“checkbox”的&lt;input&gt;元素</li>
			<li>:submit —— type属性为“submit”的&lt;input&gt;或&lt;button&gt;元素</li>
			<li>:image —— type属性为“image”的&lt;input&gt;元素</li>
			<li>:reset —— type属性为“reset”的&lt;input&gt;或&lt;button&gt;元素</li>
			<li>:button —— type属性为“button”的&lt;input&gt;或&lt;button&gt;元素</li>
			<li>:file —— type属性为“text”的&lt;input&gt;元素</li>
		</ul>
		<p>这里只需要注意一下有些属性只能是&lt;input&gt;元素可以使用，但有的&lt;input&gt;和&lt;button&gt;都可以使用。而对于&lt;form&gt;和&lt;select&gt;这些有单独标签名的表单元素则不需要这样的选择器，直接使用标签名+标识符（class/id/属性）的选择器即可。不过对于项目中表单元素通用的功能则可以根据情况直接写标签名选择器，而无需标识符。</p>
    </section>
    <!-- 状态选择器 -->
	<section>
		<h3>状态选择器</h3>
		<p>状态选择器同样可以使用CSS3中提供的4个选择器，他们分别是：“:enabled”、“:disabled”、“:checked”和“:selected”，而它们的作用分别表示表单的元素的“可用状态”、“禁用状态”、“选中状态”和“选择状态”，其中“选中状态”用于单选、多选表单元素，而“选择状态”只能用于下拉菜单元素。</p>
		<p>它的语法和上两节的“奇偶选择器”、“表单元素选择器”和“结构性伪类选择器”都是差不多的：</p>
		<p>
<code class="ideCode-js">// 可用的表单元素
$("input:enabled");

// 不可用的表单元素
$("input:disabled");

// 被选中的单选按钮
$("input[type='radio']:checked");

// 被选择的下拉列表项
$("select option:selected");
</code>
		</p>
		<p>它们的使用方式都差不多，我们以“:disabled”为例来看看它们是实际项目中的简单运用。HTML代码如下：</p>
<code class="ideCode-html"><form name="modifUserInfo">
	<div>
		<label>邮箱：</label>
		<input name="emial" type="email" value="aulence@foxmail.com" disabled="disabled">
	</div>
	<div>
		<label>昵称：</label>
		<input name="nicename" type="text" value="欧冷斯">
	</div>
	<div>
		<label>性别：</label>
		<label>
			<input name="gender" type="radio" checked="checked" disabled="disabled">
			<span>男</span>
		</label>
		<label>
			<input name="gender" type="radio" disabled="disabled">
			<span>女</span>
		</label>
	</div>
</form>
</code>
		<p>jQuery的代码如下：</p>
		<p>
<code class="ideCode-js">// 修改禁用元素的显示样式
$("input:disabled").css({
	backgroundColor: "#eeeeee",
	borderColor: "#dddddd",
	color: "#acacac",
	cursor: "not-allowed"
});
</code>
		</p>
		<h4><a href="html-pages/jquery/codeEffect/code-013.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-013.html"></iframe>
		<p>由于表单元素禁用之后事件会失效的特点，所以这里没办法通过事件去演示示例，只有通过设置样式的方式去体现被jQuery选择器选中的带有状态的元素。在以后我们学习了“jQuery属性操作”一章后再来细讨表单元素状态的切换。</p>
		<p>除了上面这4个作为表单元素状态的选择器以外，还有以下3种状态选择器：</p>
		<ul class="indent">
			<li>:focus —— 获得焦点的时候，&lt;input&gt;、&lt;button&gt;、&lt;select&gt;、&lt;textarea&gt;、&lt;a&gt;等标签可用</li>
			<li>:visible —— 可见的元素，通用</li>
			<li>:hidden —— 不可见的元素，通用</li>
		</ul>
		<p>这几个状态选择器比较简单，可自行通过实践进行理解，这里就不花篇幅去再做实例讲解了。</p>
	</section>

	<!-- 索引选择器 -->
    <section>
    	<h3>索引选择器</h3>
		<p>所谓的“索引选择器”又叫“索引下标选择器”，和原生JavaScript使用的数组下标索引形式不一样(arr[3]、userName[0]、button[1]等形式)，jQuery的语法基本都是采用<em>方法</em>的形式来表现或操作元素和数据。</p>
		<p>jQuery获取一个元素节点的索引使用<em>index()</em>方法，而查询选择一个元素的索引则是使用<em>eq(n)</em>方法，参数内的“n”就是下标，和数组下标一样是一个从0开始的自然数。</p>
		<p>基本语法：</p>
		<p>
<code class="ideCode-js">// 获取当前列表项的索引值（同级中的第几个元素）
$("ul li").index();

// 选择当前列表的第4个元素（下标为3，实际是第4个）
$("ul li").eq(3);
</code>
		</p>
		<p>索引选择器比较实用，会帮我处理一些结构性的功能，我们来看一个它们配合实现的功能。HTML代码如下：</p>
<code class="ideCode-html"><!-- 周选择列表 -->
<ul class="week">
	<li class="checked">周一</li>
	<li>周二</li>
	<li>周三</li>
	<li>周四</li>
	<li>周五</li>
	<li>周六</li>
	<li>周日</li>
</ul>
<!-- 日期列表 -->
<ul class="weather">
	<li class="show">
		<span>多云</span>
		<span>16℃~21℃</span>
	</li>
	<li>
		<span>晴天</span>
		<span>15℃~28℃</span>
	</li>
	<li>
		<span>晴天</span>
		<span>19℃~29℃</span>
	</li>
	<li>
		<span>小雨</span>
		<span>18℃~24℃</span>
	</li>
	<li>
		<span>中雨</span>
		<span>15℃~20℃</span>
	</li>
	<li>
		<span>多云</span>
		<span>17℃~22℃</span>
	</li>
	<li>
		<span>晴天</span>
		<span>16℃~21℃</span>
	</li>
</ul>
</code>
		<p>关键CSS代码如下：</p>
<code class="ideCode-css">/* 周列表 */
ul.week > li {
	padding: 6px 12px;
	border: 1px solid #acacac;
	border-right: none;
	cursor: pointer;
}
/* 周列表--选中效果 */
ul.week > li.checked {
	background-color: #acacac;
	color: #ffffff;
}
/* 天气列表 */
ul.weather > li {
	padding: 12px 20px;
	border: 1px solid #acacac;
	border-radius: 15px;
	font-size: 32px;
	display: none;
}
/* 恢复“列表项”的显示类型 */
ul.weather > li.show {
	display: list-item;
}
</code>
		<p>jQuery代码如下：</p>
<code class="ideCode-js">// 点击选择日期
$("ul.week li").click(function () {
	// 获取索引下标
	var idx = $(this).index();

	// 为当前节点添加选中效果的class，移除兄弟节点中带有这个class元素的“checked”样式
	$(this).addClass("checked").siblings("li.checked").removeClass("checked");

	// 移除带有“show”这个class元素的“show”样式
	$("ul.weather li.show").removeClass("show");
	// 为对应索引值的“天气”列表项添加“show”（显示为列表项）这个样式
	$("ul.weather li").eq(idx).addClass("show");
});
</code>
		<h4><a href="html-pages/jquery/codeEffect/code-014.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-014.html"></iframe>
		<p>可以点击上面“运行效果”链接打开新的页面，然后通过在浏览开发者工具内的“sources”栏里打开HTML文件打断点观察上例代码中的“idx”变量每次在点击日期后运行出来的值，从而深入地理解index和eq这两个方法。</p>
		<p>“eq”索引选择器其实英文单词“equal”的缩写，表示“等于、相等”的意思，也就是说既然有等于就有大于和小于了。的确，在jQuery中用于查询小于当前索引值的选择器是<em>:lt(n)</em>，而大于当前索引值的选择器是<em>:gt(n)</em>。也许你已经注意到了，它们和eq()不一样，它们不是方法，而且在jQuery中也没有这两个方法，它们的基本语法是：</p>
<code class="ideCode-js">// 把索引值小于3（即0、1、2）的li的字体颜色设为红色
$("ul li:lt(3)").css("color", "#ff0000");

// 把索引值大于4的li的字体颜色设为蓝色
$("ul li:gt(4)").css("color", "#0000ff");
</code>
		<p>遗憾的是jQuery中并没有“小于等于”、“大于等于”的选择器或方法，所以要实现类似“大于等于”这样是选择的时候只有自行去实现了。当然如果要将:lt(n)和:gt(n)以方法的形式表现，那去用next()和prev()方法系列就是。（“系列”如：next()、nextAll()、nextUnitl()、prev()等，它们在本章的“同级选择器”一节里有详细讲解）</p>
    </section>

	<!-- 章节练习 -->
	<section class="unitPractice">
		<h3>&lt;章节练习二&gt;</h3>
		<p>完善上一节“索引选择器”通过点击日期显示不同天气的例子：</p>
		<ul>
			<li>当天气为“晴天”的时候“日期选择”的背景色和下方“气候气温”的字体颜色为“橙色”</li>
			<li>当天气为“雨天”的时候对应的颜色设置为“蓝色”（大、中、小颜色可以使用偏青色的深蓝、蓝和浅蓝来分别表示）</li>
			<li>当天气为“多云”的时候对应的颜色设置为“灰色”</li>
		</ul>
		<p>&lt;提示&gt;使用“switch-case”条件语句实现，样式类（class）通过CSS预先设置好，然后用例子中出现过的addClass()和removeClass()两个方法来完成对样式的添加和移除。</p>
	</section>

    <!-- 动画元素选择器 -->
    <section>
    	<h3>动画元素选择器</h3>
		<p>动画元素选择器（也可叫做“执行动画状态中的选择器”）“<em>:animated</em>”可以选择到正常执行动画的元素，它需要配合jQuery的<em>animate()</em>方法使用，而不能配合CSS里面的“animation”属性使用。</p>
		<p>虽然这个方法还没有讲解过，但也可以从这个例子从看出这个选择器的作用。</p>
		<p>HTML代码部分：</p>
<code class="ideCode-html"><!-- 操作按钮组 -->
<div>
	<button class="runDiv" type="button">运行</button>
	<button class="refics" type="button">作色</button>
</div>
<!-- 运行动画的元素 -->
<div class="animateDiv"></div>
</code>
		<p>jQuery代码部分：</p>
<code class="ideCode-js">// 运行
$("button.runDiv").click(function () {
	// 让不在执行动画状态的div执行动画（正在执行动画则不会生效）
	$(".animateDiv:not(:animated)").animate({
		width: "100%"
	},3000);
});

// 作色
$("button.refics").click(function () {
	$("div:animated").css("backgroundColor", "#ff8800");
});
</code>
		<h4><a href="html-pages/jquery/codeEffect/code-015.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-015.html"></iframe>
		<p>从上例代码中可以观察出，当前页面如果在没有按下“运行”按钮，或3秒动画执行完成后点击“作色”按钮都是没有反应的，只有在这3秒动画运行的期间“作色”按钮的功能才会生效，这就是“:animated”选择器在这里起的作用。</p>
		<p>除此之外还需要注意一点，就是jQuery中的这个animate()方法不能使CSS3中的tranform的各个值生效，这点也是比较遗憾的。对于这个方法我们会在以后的“jQuery动画效果”一章中详细讲解。</p>
    </section>

    <!-- 哈希目标选择器 -->
    <section>
    	<h3>哈希目标选择器</h3>
		<p>该选择器相对于其它选择器说，理解难度稍微要大一些，当然它和CSS里的“:target”选择器差不多就是同一个东西。这个选择器生效的条件是当页面内触发锚点指向改变的时候（这时hash值也会动态改变），而且始终选择和hash值同名的元素，也就是说这个选择器是动态的，它随着hash值的改变而动态改变选择的元素。</p>
		<p>文字的描述总是没有那么直观，我们通过一个稍微生动一点的例子来帮助理解。HTML代码如下：</p>
<code class="ideCode-html"><!-- 页面导航 -->
<nav>
	<ul>
		<li class="checked">
			<a href="#home">首页</a>
		</li>
		<li>
			<a href="#product">产品</a>
		</li>
		<li>
			<a href="#server">服务</a>
		</li>
		<li>
			<a href="#about">关于</a>
		</li>
	</ul>
</nav>
<!-- 页面内容 -->
<ul class="pages">
	<li class="loading">&lt;img src="../../../img/content/loading_48.png"&gt;</li>
	<li id="home">首页的内容，首页的内容，...,首页的内容</li>
	<li id="product">产品的内容,产品的内容,...,产品的内容</li>
	<li id="server">服务的内容,服务的内容,...,服务的内容</li>
	<li id="about">关于的内容,关于的内容,...,关于的内容</li>
</ul>
</code>
		<p>关键CSS代码如下：</p>
<code class="ideCode-css">ul > li {
	padding: 10px 24px;
	float: left;
}
nav li.checked {
	background-color: #2396ef;
}
nav li.checked a {
	color: #ffffff;
}
.pages li:not(.loading) {
	display: none;
}
.pages .loading {
	position: absolute;
	left: 0;
	top: 0;
}
.pages .loading img {
	display: block;
	animation: loading 1.2s linear infinite;
}
@keyframes loading {
	0% { transform: rotate(0deg); }
	100% { transform: rotate(360deg); }
}
</code>
		<p>jQuery的代码如下：</p>
<code class="ideCode-js">// 设置默认的hash元素为“home”
location.hash = "home";

// 存储导航按钮节约查询性能
var navButton = $("nav a");

// 页内切换等待载入
navButton.click(function () {
	// 切换选中效果
	$(this).parent().addClass("checked").siblings().removeClass("checked");

	// 隐藏所有“页面”，除了载入效果
	$(".pages li:not(.loading)").css("display", "none");
	// 显示载入效果
	$(".pages .loading").css("display", "list-item");

	// 这里加入延时函数是因为JS执行的时机会先于浏览器（大多数）的行为，而我们需要保证浏览器行为完成后再执行我们的代码。可以利用这点做页面内的载入等待效果
	setTimeout(function () {
		// “载入完成”后隐藏载入效果
		$(".loading").css("display", "none");
		$("li:target").css("display", "list-item").siblings(":not(.loading)").css("display", "none");
	}, 1200);
});

// 触发“首页”导航按钮的点击事件
navButton.eq(0).trigger("click");
</code>
		<h4><a href="html-pages/jquery/codeEffect/code-016.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-016.html"></iframe>
    </section>

    <!-- 元素判断 -->
    <section>
    	<h3>元素判断</h3>
		<p>无论是对于CSS还是对于jQuery来说，要查询一个元素选择器的写法通常不是唯一的，比如说对于这样的一个HTML的结构来说：</p>
<code class="ideCode-html"><div id="test">
	<ul class="contectList">
		<li>内容1</li>
		<li class="checked">内容2</li>
		<li>内容3</li>
		<li>内容4</li>
	</ul>
</div></code>
		<p>要找到class为“checked”的列表项，在jQuery中可以是“$("#test ul li.checked")”，也可以是“$("#test .checked")”，如果页面内没有其他同名的元素，还可以直接就写成“$(".checked")”。总之对于HTML这样的结构语言，要找到某一个节点方式是比较多的。</p>
		<p>但有的时候，我们要找的元素都有同样的标签名、属性名和标识符的时候，怎么判断当前的元素就是我们需要选择的元素呢？这个时候就可以利用jQuery提供的<em>is()</em>方法来帮助判断。</p>
		<p>基本语法：</p>
<code class="ideCode-js">// 当前的元素是一个div标签元素
$(this).is("div");

// 当前元素的下一个元素节点是一个p标签元素
$(this).next().is("p");

// 当前元素的父级是一个导航菜单（ul.navMenu）下的列表项
$(this).parent().is($("ul.navMenu li"));
</code>
		<p>is()方法根据选择器、元素或jQuery对象来检测匹配元素集合，如果这些元素中至少有一个元素匹配给定的参数，则返回“true”。</p>
		<p>除了上述以外，is()方法的参数还可以是一个函数。我们来看这样一个实例，HTML代码如下：</p>
<code class="ideCode-html"><ul class="list-span">
	<li><span>span1</span></li>
	<li><span>span1</span>-<span>span2</span></li>
	<li><span>span1</span>-<span>span2</span>-<span>span3</span></li>
	<li><span>span1</span>-<span>span2</span>-<span>span3</span>-<span>span4</span></li>
</ul>
</code>
		<p>jQuery代码如下：</p>
<code class="ideCode-js">// 通过点击li触发事件判断
$("ul.list-span > li").click(function() {
	// 用is()方法得出一个布尔值
	var isTwoSpan = $(this).is(function() {
		// 在“li”里含有两个span标签条件成立的布尔值
		return $("span", this).length === 2;
	});

	// 如果含有两个span标签的li变为蓝色背景
	if (isTwoSpan) {
		 $(this).css("background-color", "#64bcfd");
	}
	// 否则变为红色背景
	else {
		 $(this).css("background-color", "#fe7589");
	}
});
</code>
		<h4><a href="html-pages/jquery/codeEffect/code-017.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-017.html"></iframe>
		<p>is()方法的这些特性都可以帮助我们完成一些比较复杂的DOM操作逻辑，当然对其的理解难度也会相对于同类的其它方法稍微难一些。它在我们后续章节里会讲到的“事件对象”里也有非常重要的运用，到时候我们会再度结合is()方法来进行讲解。</p>
    </section>

    <!-- 文本包含选择器 -->
    <section>
    	<h3>文本包含选择器</h3>
		<p>文本包含选择器是返回含有指定文本的标签节点的一个选择器，它的出现简化了我们的DOM操作逻辑，无需再通过循环加上正则的方式去寻找我们需要匹配的元素节点。</p>
		<p>它的基本使用语法如下：</p>
		<code class="ideCode-js">$("div:contains('需要匹配的字符串')");</code>
		<p>接下来我们通过一个简单的示例来理解这个选择器的使用方式。HTML代码如下：</p>
<code class="ideCode-html"><p>这是青蛙嘛？</p>
<p>这显然不是青蛙</p>
<p>那是一只什么蛙？</p>
<p>其实这是癞蛤蟆</p>
<p>哦，原来如此</p></code>
		<p>jQuery代码如下：</p>
<code class="ideCode-js">// 将含有“这是”二字的p标签进行字体和颜色设置
$("p:contains('这是')").css({
	fontSize: "28px",
	fontFamily: "华文隶书",
	color: "#f368fe"
});
</code>
		<h4><a href="html-pages/jquery/codeEffect/code-018.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-018.html"></iframe>
		<p>对于这个选择器只需要搞清楚一点，我们要匹配的不是我们设置在这个选择器参数里面的文本内容，而是带有这个文本内容的标签节点元素。而且需要匹配的文本格式需要和参数里的一致，也就是说空格、换行符中间多余的字符等都会影响匹配结果，而且选择器参数只能设置为<em>纯文本</em>。</p>
    </section>

    <!-- 标签包含选择器 -->
    <section>
    	<h3>标签包含选择器</h3>
		<p>和文本包含器一样，jQuery还提供了标签包含选择器及对应的方法<em>has(Element)</em>。它会返回一个包含了指定选择符的节点的集合。</p>
		<p>它有两种语法表现形式：</p>
<code class="ideCode-js">// 包含了p标签的所有div标签
$("div").has("p");

// 另外一种语法形式
$("div:has(p)");</code>
		<p>我们通过一个实例来看看这个方法选择器的使用方式，HTML代码如下：</p>
<code class="ideCode-html"><ul class="has">
	<li>
		<span>文本内容标签span1</span>
	</li>
	<li>
		<a href="https://www.baidu.com" class="disabledLink" target="_blank">超链接内容标签a1</a>
	</li>
	<li>
		<span>文本内容标签span2</span>
	</li>
	<li>
		<a href="https://www.baidu.com" target="_blank">超链接内容标签a2</a>
	</li>
</ul></code>
		<p>jQuery的代码如下：</p>
<code class="ideCode-js">// 将含有指定标签的元素背景设置为浅灰色
// 将子元素的设置为不可点击，没有下划线的灰色字体
$("li").has("a.disabledLink").css("backgroundColor", "#eeeeee").children().css({
	pointerEvents: "none",
	textDecoration: "none",
	color: "#999999"
});
// 上方的选择器的写法也可以写成以下形式
$("li:has(a.disabledLink)");</code>
		<h4><a href="html-pages/jquery/codeEffect/code-019.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-019.html"></iframe>
		<p>虽然说这两种方式在最终结果上来说似乎没有什么区别，但是最好还是使用示例中的第一种，即方法的形式。一方面可以节约一次jQuery正则匹配字符串方法的开销，另外一方面也可以使代码可读性更高，最重要的是用“:has”选择器的方式如果要传入变量的话需要进行字符串拼接，使得代码容错率降低，而使用方法的形式只需要传入一个变量名即可。多方比较，就算不这样推荐，相信在大家心目中也有自己的选择了。</p>
    </section>

	<!-- 元素筛选选择器 -->
	<section>
		<h3>元素筛选选择器</h3>
		<p>元素筛选选择器<em>filter()</em>和元素判断方法“is()”使用方式几乎一样，但区别是，is()方法返回的是一个布尔值，而filter()返回的就是被匹配的元素集合本身。</p>
		<p>基本语法如下：</p>
<code class="ideCode-js">// 匹配集合内class名称为“selected”的所有p标签
$("p").filter(".selected");

// 匹配集合内class名称为“selected”的首个p标签
$("p").filter(".selected, :first");

// 匹配集合内不含有ol标签的所有p标签
$("p").filter(function(index) {
	return $("ol", this).length == 0;
});
</code>
		<p>由于它的语法形式和我们之前接触过的几个选择器比较相似，这里就不做实例演示了，大家可以自行进行操作实践。</p>
	</section>

    <!-- 文本或标签包含选择器 -->
    <section>
    	<h3>文本或标签包含选择器</h3>
		<p>该选择器会返回包含了标签或文本的元素节点的集合，简单的说，就是只要内容不为空就会返回所匹配该系列的节点。基本语法如下</p>
<code class="ideCode-js">// 返回所有含有子节点的div元素
$("div:parent");
</code>
		<p>我们来看看这样一个需求的实例，当li内含有信息则添加一个带有“卡片”样式的class，HTML代码如下：</p>
<code class="ideCode-html"><ul class="infoCard">
	<li>
		<div>
			<h3>塞上曲送元美</h3>
			<p>白羽如霜出塞寒，胡烽不断接长安。</p>
			<p>城头一片西山月，多少征人马上看。</p>
		</div>
	</li>
	<li><!--这里没有内容--></li>
	<li>
		<div>
			<h3>立春偶成</h3>
			<p>律回岁晚冰霜少，春到人间草木知。</p>
			<p>便觉眼前生意满，东风吹水绿参差。</p>
		</div>
	</li>
</ul></code>
		<p>关键CSS代码如下：</p>
<code class="ideCode-css">ul.infoCard {
	width: 480px;
	list-style: none;
	margin: 0 auto;
	padding: 0;
	padding-bottom: 12px;
}
ul.infoCard li.hasContent {
	padding: 6px 12px;
	background-color: #f0e9ca;
	border: 1px solid #f5f0e5;
	border-radius: 15px;
	color: #666666;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
	margin-bottom: 20px;
}
ul.infoCard li.hasContent h3 {
	color: #333333;
	margin: 10px 0;
}
</code>
		<p>jQuery代码如下：</p>
<code class="ideCode-js">// 为含有标签或文本的li元素添加“卡片”效果的class
$("ul.infoCard li:parent").addClass("hasContent");</code>
		<h4><a href="html-pages/jquery/codeEffect/code-020.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-020.html"></iframe>
		<p>上例中原本有3个&lt;li&gt;标签，但由于第2个&lt;li&gt;标签没有文本或标签，所以没有被匹配去添加Class样式。而没有被匹配上的li元素没有任何样式，所以不占据页面的显示空间，即不可见。</p>
		<p>当然，页面上是不推荐出现任何空的标签对的。就算是出现空标签也是动态生成来的，有的时候为了界面视图结构会将一些空数据也显示出来，但空着一个容器在那里影响显示效果，这个时候就可以利用这样的思路去解决显示样式的问题。</p>
    </section>

    <!-- 空内容选择器 -->
    <section>
    	<h3>空内容选择器</h3>
		<p>空内容选择器<em>:empty</em>和上一节的文本或标签包含选择器刚好相反，是标签内不含有文本或标签的节点的集合。它的基本语法格式为：</p>
<code class="ideCode-js">// 匹配出所有空的td元素
$("td:empty");</code>
		<p>这个选择器的使用方式和之前选择器的使用方式也是一样的，所以在这里就不做实例演示了。</p>
    </section>

	<!-- 章节练习 -->
	<section class="unitPractice">
		<h3>&lt;章节练习三&gt;</h3>
		<p>编写一个5行5列的表格，然后完成以下需求：</p>
		<ol>
			<li>用jQuery选择器实现奇偶隔行变色，颜色自定</li>
			<li>表格的左后一列标题为“操作”，单元格内容为一个button按钮</li>
			<li>其中第二和第四行按钮状态为“禁用”，用jQuery选择器找出这些禁用按钮，为其添加一个无边框、无背景色，字体颜色为“#888888”的class样式类</li>
			<li>预留出至少3个空的td标签，将这些空的td用jQuery找出来填充“#eeeeee”的背景色</li>
			<li>注意颜色的搭配和样式生效的优先级问题，保证需求中的每个效果都能正常实现</li>
		</ol>
	</section>
</root>



